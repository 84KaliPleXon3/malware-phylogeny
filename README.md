# An algorithm to calculate malware phylogeny, an example and counterexample

Source code for malware can easily be had by [googling](https://www.google.com/search?q=web+shell+wso+filesman),
[searching on pastebin](http://pastebin.com/search?q=WSO)
or running a [WordPress honey pot](http://stratigery.com/phparasites/).
Much of it is interpreted languages, like PHP or Perl.

I will use "Web Shell by oRb" (a.k.a "WSO", "FilesMan") and the omnipresent IRC Perl bot
(Perl/Shellbot) as examples.

"Web Shell by oRb" (also called "WSO", "FilesMan" and "AntiChat shell") is by far the most
popular web shell downloaded to hacked CMS web sites today. It's often reformatted, obfuscated
or otherwise slightly customized before hiding it in a WordPress installation.
Many distinct versions exist, including [one under active development](https://github.com/wso-shell/WSO).

The omnipresent IRC Perl bot is referred to by antivirus firms as
"Perl/Shellbot" or some form of that indicating a derivative. A typical variant
can be had from [Pastebin](http://pastebin.com/CJpxW5tx).  Perl/Shellbot is a piece
of Perl that understands the IRC protocol. Specially formatted messages from
the botherder cause the bot to do things, like perform a UDP packet flood, run
a command via the system's shell, or look up "dorks" in every search engine on
the planet. The code arrives in a dazzling number of variants, some with
function names and commentary in Portugese, others with function names & etc in
English. Every botherder seems to do minor customization.

Casual reading of several variants of either WSO or Perl/Shellbot will convince
you that the variants are "related". It seems that one variant "evolved" into another via a
process of spammers making small changes to suit their needs. Perhaps a selection of the
fittest happens when one script kiddy copys the succssful code of another script kiddy.
Collection and comparison of variants should allow the construction of a "family tree"
of variants. This project is a description and demonstration of one method of constructing
the family tree, or phylogeny, of WSO, and less succesfully, of Perl/Shellbot.

##Source code malware evolution

Ordinary biological evolution analogies are ill-suited to reconstructing
malware phylogenies.
Biological phylogenies assume binary splits between two clades, and 
assume that we know the sister clades, but can't identify the
the common ancestor.
Malware can split many times from a single, identifiable common ancester.
Biological phylogenies assume a single common ancestor.
Malware often, maybe almost always, has more than
a single ancestor.

Souce code malware seems to evolve by feature addition or subtraction.
People modifiying malware add small chunks of code, code that might phone home
with URL, user ID and password, or just evaluate some code when
executed with a special CGI-BIN parameter.
Sometimes entire functions or subsystems are transplanted from another
program.

When the "source code" (DNA) of biological families is available, it rarely
shows evolution by adding or subtracting entire "features". Biological evolution
appears to happen by gradual changes over large extents of a clade's DNA. 
The closest biological analogy of the way source code malware evolves would seem
to be [horizontal gene transfer](https://en.wikipedia.org/wiki/Horizontal_gene_transfer).

##Biology-influenced phylogenies

Traditional biology phylogenies are sometimes calculated with a "distance"
metric, and tree construction algorithms like
[Neighbor Joining](https://en.wikipedia.org/wiki/Neighbor_joining).
This section illustrates such a calculation.

###Normalized Compression Distance

I used the NCD algorithm from [Common Pitfalls Using The Normalized Compression Distance](http://www.ims.cuhk.edu.hk/~cis/2005.4/01.pdf)
it seems to give closer-to-zero "distance" of a piece of code to itself. The code is in
`distance_calc.php`

    NCD(x,y) = max(C(xy) - C(x), C(yx) - C(y)}/max(C(x), C(y))

`NCD(x,y)` is the normalized compression distance from string `x` to string `y`,
`max(a, b)` is the numerical maximum of numbers `a` and `b`, and `C(e)` is the
size in bytes of compressed string `e`. `xy` is string `x` with string `y`
appended. I used PHP's `bzcompress()` function. File `distance_calc.php`
implements the NCD calculations.

The following phylogeny is for a group of versions of "Web Shell by oRb" (WSO), described
futher below, except for `lfiscanner.php` and `fx29`, which are secondary ancestors
of some versions of WSO.
All WSO versions are files in `exemplars/`, PHP source code, normalized by [pretty
printing](https://github.com/nikic/PHP-Parser), and removing ASCII carriage
return characters. I did an NCD calculation on all files in `exemplars`.
Using the neighbor joining algorithm, I calculated the following phylogeny.
To get a rooted tree from neighbor joining, you have to pick an "outgroup". I
chose `lfiscanner.php`.

![WSO phylogeny by NCD and neighbor joining](https://raw.githubusercontent.com/bediger4000/malware-phylogeny/master/nj_phylogeny.png)

Horizontal lengths of branches are proportional to the normalized
compression distance separating source files. You can re-generate the
above image by invoking `make nj_phylogeny.png`. The file `makefile`
describes how to rebuild `nj_phylogeny.png` from scratch.

NCD and neighbor joining get some parts of the phylogeny correct. Although I
chose `lfiscanner` as the out group, it correctly found the `fx29` web shell as
the next most distantly-related piece of code. It gets the basic split between
WSO 2.4 and WSO 2.5 clades, but mixes version 2.8 and 3.1 in the 2.4-based
clade - version 2.8 is clearly a minor hack of version 2.5.1, differing only by
yet another phone home. Version 3.1 descends from 2.5 by the verbatim
incorporation of a local-file-include scanner from `lfiscanner.php`.

The assumptions inherent in neighbor joining make version 2.4 into an outgroup
of a clade.  In addition to comprising the immediate ancestor of a number of
species, version 2.4 should appear as the ancestor of a linear progression of
2.5 to 2.5.1 to 2.8. The entire issue of multiple ancestry doesn't appear at
all.  `fx29` and `lfiscanner.php` should show up as auxilliary ancestors to
multiple variants that have a WSO variant as a primary ancestor.

All told, this phylogeny is roughly correct, but has too many flaws to be more than a general
guide.

##Algorithm

Because malware evolves by feature addition and subtraction, and not by changes in genomes,
I tried to use the pieces of source code that differ between species, and
the pieces of source code that remain common between all members of a clade
to derive a phylogeny. I explictly allow for multiple ancestry.

###Determine Features

Determining which features to use is important, and not amenable to automation. The
algorithm needs at least one feature (line or lines of source code) common
between an ancestor and all of its desendants. It will calculate multiple
independent trees if this condition is not met.

The algorithm needs each pair of species to differ in at least one trait, 
and descendants must differ from immediate ancestors by at least one trait.

###Description

Species are represented by instances of a data structure that can contain a set
of features (traits), and allow each feature to be marked. Sets of features in
two species must be comparable to determine a subset relationship.  The data
structure must be able to keep references to immediate descendant species. The
data structure must be capable of being marked to indicate that it has at least
one ancestor. This project has such a data structure in file `phylogeny/Species.php`

1. Order species in a list by decreasing number of features.
2. Remove species with largest number of feature from ordered species list. This species becomes the current species.
3. Compare current species featuries to next species' features in decreasing order of number of features.
4. When a species on the list has features that are a strict subset of current feature list,
   and contain a feature previously unmarked in the current species,
   assign current species as child of other species.
5. Mark all traits of the current species that are common to the new parent.
6. If more than one trait is unmarked, repeat from (3)
7. If no more than one trait is unmarked, go to (2).
8. If you have compared traits of the current species to all species left on the list,
   and the current species hasn't been added to any species as a child,
   and still have more than one unmarked trait, add the current species
   to the set of root species. Go to (2)
9. When the ordered list is empty, stop.
10. Starting from the set of root species created in step (8), use each
    root node's children to draw the resulting phylogeny.

I implemented the algorithm in file `phylogeny/p2.php` in this repository.

###Performance

The algorithm above always terminates. Every species gets popped off ordered list of species,
and there's only a finite number of comparisons (traits or species) made.

####Worst case 
Consider a phylogenetic tree with one root, many children, and no
grandchildren, where all children have a number of common traits. Only one
trait differentiates between any two child species.  
The first species of N gets compared to N - 1 child species before being assigned
to the root species. The second species gets compared to N - 2 species, the third
species gets compared to N - 3 species, and so forth. The number of species-to-species
comparisons is:

	(N-1)+(N-2)+(N-3)+...+(N - (N-2))(N - (N-1))

This is just N things taken two at a time, which is: N!/(2!(N - 2)!)
This formula reduces to N(N-1)/2 or  (N - N*N)/2. Thus the algorithm takes O(N*N) in the worst case.


###Effect of ill-chosen features

Two species without at least one trait to differentiate them show up as sister species.
Correctly chosing traits could cause one to show up as the child of the other.

Using a trait for one of two sister species that's not in the real ancester can lead to inversions
of descent.

##Example: Web Shell by oRb

###Description

WSO is a "web shell", a single PHP file that invoked by a
web browser, that can perform system administration tasks like examining system configuration,
manipulating files, uploading or downloading files. It has "hacker" oriented features,
like MySQL and Postgres database manipulation, password guessing and string format manipulation.

One of the interesting things about WSO code is that the original author chose to include
a version string, "2.0" or "2.5" or "3.1". This gives a natural feature to do initial
categorization of files into versions.
The code versions 2.0 through 2.5 looks like
a diligent developer wrote it. Each version has bugs fixed and features added over the version
before. The versions other than 2.0 through 2.5 are quite different. They don't include
bug fixes, but rather include whole chunks of code. These chunks range from quietly emailing
home whenever that version is run, to "mass defacing" or "local file include" functions.
No bugs get fixed, but the version numbering miraculously stays indepenent, in that there aren't
two clades of WSO both version numbered 2.8, for example. Evolution by feature addition is
obviously the mode of development outside of the version 2.0 through 2.5 progression.
Version 2.5 is the only code I have confidence of possessing the original.

![WSO phylogeny by feature addition](https://raw.githubusercontent.com/bediger4000/malware-phylogeny/master/wso_phylogeny.png)

You should be able to reproduce the phylogeny above by cloning this repository,
and issuing a `make wso_phylogeny.png` command.

My selection and enumeration of features of WSO is in the script `find_traits`.
I determined the features by careful manual code examination. If you read
`find_traits` and the WSO exemplars carefully, you will notice that I've done
some clever trait selection. Every version and variant up to 2.4 (and 2.4
descendants not related to 2.5) keeps information in a PHP session variable,
which resides on the server. Versions 2.5 and descendants (2.5.1, 2.8, 3.1) keep the same
information in HTTP cookies, presumably to avoid leaving traces behind on the
exploited server. I did not use "use PHP session" as a feature, but I did
use "use HTTP cookies" as a feature. This works around the algorithm not
accounting for feature deletions, just additions. Workarounds may not be
possible in all such situations.

Why does WSO appear in so many versions? "oRb" wrote the code in a mostly modular fashion.
"oRb" actually designed the program. This makes it easier to add backdoors or phone-homes,
change password, modify page headers and footers, or add new functions.
This is in contrast to other web shells like `fx29`, `c99` or `r57`. These other web shells
are an unholy mess inside, with little or no modularity, and no easy way to add functionality.
"oRb" also shepherded WSO through a corporate-style linear improvement process from versions 2.0
through 2.5 

##Counter example: Perl/Shellbot

There's an instance of WSO, `exemplars/webo`, which does not admit the use of the algorithm
above. It's clearly a cut down version of `exemplars/2.5`, but many functions present
in `2.5` are missing in `webo`, and a general renaming of functions took place.

Should have an NCD/neighbor joining tree here

Difficulty in picking out traits - some obviously later instances are selectively
trimmed versions of early instances. Huge variety of extra features added on.
Originally in Portugese, later transliterated into English.
