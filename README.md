# An algorithm to calculate malware phylogeny, an example and counterexample

Source code for malware can easily be had by [googling](https://www.google.com/search?q=web+shell+wso+filesman),
[searching on pastebin](http://pastebin.com/search?q=WSO)
or running [WordPress honey pot](http://stratigery.com/phparasites/).
Much of it is interpreted languages, like PHP or Perl.

I will use "Web Shell by oRb" (a.k.a "WSO", "FilesMan") and the omnipresent IRC Perl bot
(Perl/Shellbot.B) as examples.

"Web Shell by oRb" (also called "WSO", "FilesMan" and "AntiChat shell") is by far the most
popular web shell downloaded to hacked CMS web sites today. It's often reformatted, obfuscated
or otherwise slightly customized before hiding it in a WordPress installation. It comes
in many distinct versions, including [one under active development](https://github.com/wso-shell/WSO).

The omnipresent IRC Perl bot is referred to by antivirus firms as
"Perl/Shellbot" or some form of that indicating a derivative. A typical variant
can be had from [Pastebin](http://pastebin.com/CJpxW5tx).  Perl/Shellbot is a piece
of Perl that understands the IRC protocol. Specially formatted messages from
the botherder cause the bot to do things, like perform a UDP packet flood, run
a command via the system's shell, or look up "dorks" in every search engine on
the planet. The code arrives in a dazzling number of variants, some with
function names and commentary in Portugese, others with function names & etc in
English. Every botherder seems to do minor customization.

Casual reading of several variants of either WSO or Perl/Shellbot will convince
you that the variants are "related". It seems that one variant "evolved" into another via a
process of spammers making small changes to suit their needs. Perhaps a selection of the
"fittest" happens when one script kiddy copys the succssful code of another script kiddy.
Collection and comparison of variants should allow the construction of a "family tree"
of variants. This project is a description and demonstration of one method of constructing
the family tree, or phylogeny, of WSO, and less succesfully, of Perl/Shellbot.

##Source code malware evolution

Ordinary biological evolution analogies are ill-suited to guessing
malware phylogenies.
Biological phylogenies assume binary splits between two clades, and 
assume that we know the sister clades, but can't identify the
the common ancestor.
Malware can split many times from an identifiable common ancester.
Biological phylogenies assume a single common ancestor.
Malware often, maybe almost always, has more than
a single ancestor.

Souce code malware seems to evolve by feature addition or subtraction.
Malware modifiers add small chunks of code, code that might phone home
with URL, user ID and password, or just evaluate some code when
executed with a special CGI-BIN parameter.
Sometimes entire functions or subsystems are transplanted from another
program.

When the "source code" of biological families is available, it rarely if ever
shows evolution by adding or subtracting entire "features". Biological evolution
appears to happen by gradual changes over large extents of a clade's DNA. 

##Neighbor Joining

Tradtional biological phylogenies are sometimes calculated with some "distance"
metric, and tree construction algorithms like
[Neighbor Joining](https://en.wikipedia.org/wiki/Neighbor_joining).

###Normalized Compression Distance

I used the NCD algorithm from [Common Pitfalls Using The Normalized Compression Distance](http://www.ims.cuhk.edu.hk/~cis/2005.4/01.pdf)
it seems to give closer-to-zero "distance" of a piece of code to itself.

All files in `exemplars/` are PHP source code, normalized by [pretty printing](https://github.com/nikic/PHP-Parser),
and removing ASCII carriage return characters. I did an NCD calculation on all PHP malware in `exemplars`,
and using the neighbor joining algorithm, I produced the following phylogeny. To get a rooted tree
from neighbor joining, you have to pick an "outgroup". I chose `lfiscanner.php`.

![WSO phylogeny by NCD and neighbor joining](https://raw.githubusercontent.com/bediger4000/malware-phylogeny/master/nj_phylogeny.png)

The horizontal lengths of branches are proportional to the normalized compression distance the
source files are apart.

NCD and neighbor joining get some parts of the phylogeny correct. Although I chose `lfiscanner`
as the out group, it correctly found the `fx29` web shell as the next most distantly-related piece
of code. It gets the basic split between WSO 2.4 and WSO 2.5 clades, but mixes version 2.8 and 3.1
in the 2.4-based clade - version 2.8 is clearly a minor hack of version 2.5.1, differing only
by yet another phone home. Version 3.1 descends from 2.5 by the verbatim incorporation of a
local-file-include scanner from `lfiscanner.php`.

The assumptions inherent in neighbor joining make version 2.4 into an out group of a clade,
where it should be seen as the common ancestor of most of the verions in the sister clade.
Version 2.5 is the only code I have confidence of possessing the original. It should be
seen as the ancestor of a linear progression of 2.5 to 2.5.1 to 2.8. The entire issue of
multiple ancestry doesn't come into it at all, as `fx29` and `lfiscanner.php` are
secondary ancestors to multiple variants that have a WSO variant as a primary ancestor.

All told, this phylogeny is roughly correct, but has too many flaws to be more than a general
guide.

##Algorithm

Because malware evolves by feature addition, and not by changes in their genomes,
it makes sense to use the pieces of source code that differ between species, and
the pieces of source code that remain common between all members of a clade.

###Determine Features

###Description

1. order species by decreasing size of feature list in an array
2. Remove species with largest feature list from  array
3. Compare current feature list to other species in order from next largest feature list to smallest
4. When the other species has a feature list that's a strict subset of current feature list,
   and contains a feature previously unmarked, assign current species as child of other species.
5. Mark all traits of the current species common to the new parent.
6. If more than one trait is unmarked, repeat from (3)
7. If no more than one trait is unmarked, go to one.
8. If you have compared traits of the current species to all species left,
   the current species hasn't been added to any species as a child,
   and still have more than one unmarked traits, add the current species
   to the set of root species.

###Performance

Always terminates. Every species gets popped off ordered list of species.

####Worst case 
One root, many children, no grandchildren. All children have a lot of common traits,
one trait differentiating.  Worst case O(n^2) for comparison of traits.

###Effect of ill-chosen features

Two species without at least one trait to differentiate them show up as sister species,
when one should possibly show up the child of the other.

Picking a trait that's not in the real ancester can lead to inversions
of descent.

##Example: Web Shell by oRb


###Description

WSO is a "web shell", a single PHP file that can be invoked by a
web browser, that can perform system administration tasks like examining system configuration,
manipulating files, uploading or downloading files. It has "hacker" oriented features,
like MySQL and Postgres database manipulation, password guessing and string format manipulation.

One of the interesting things about WSO code is that the original author chose to include
a version string, "2.0" or "2.5" or "3.1". This gives a natural feature to do initial
categorization of files into versions.
The code versions 2.0 through 2.5 looks like
a diligent developer wrote it. Each version has bugs fixed and features added over the version
before. The versions other than 2.0 through 2.5 are quite different. They don't include
bug fixes, but rather include whole chunks of code. These chunks range from quietly emailing
home whenever that version is run, to "mass defacing" or "local file include" functions.
No bugs get fixed, but the version numbering miraculously stays indepenent, in that there aren't
two clades of WSO both version numbered 2.8, for example. Evolution by feature addition is
obviously the mode of development outside of the version 2.0 through 2.5 progression.

![WSO phylogeny by feature addition](https://raw.githubusercontent.com/bediger4000/malware-phylogeny/master/wso_phylogeny.png)

Why does WSO appear in so many versions? "oRb" wrote the code in a mostly modular fashion.
"oRb" actually designed the program. This makes it easier to add backdoors or phone-homes,
change password, modify page headers and footers, or add new functions.
This is in contrast to other web shells like `fx29`, `c99` or `r57`. These other web shells
are an unholy mess inside, with little or no modularity, and no easy way to add functionality.
"oRb" also shepherded WSO through a corporate-style linear improvement process from versions 2.0
through 2.5 

##Counter example: Perl/Shellbot

There's an instance of WSO, `exemplars/webo`, which does not admit the use of the algorithm
above. It's clearly a cut down version of `exemplars/2.5`, but many functions present
in `2.5` are missing in `webo`, and a general renaming of functions took place.


Difficulty in picking out traits - some obviously later instances are selectively
trimmed versions of early instances. Huge variety of extra features added on.
Originally in Portugese, later transliterated into English.
