# An algorithm to calculate malware phylogeny, an example and counterexample

Source code malware can easily be had by googling or running a wordpress
honey pot. Much of it is interpreted languages, like PHP or Perl.

##Source code malware evolution

Ordinary biological evolution analogies are ill-suited to guessing
at malware phylogeny.
Biological phylogenies assume binary splits between two clades, and 
assume that we know the sister clades, but can't identify the
the common ancestor.
Malware can split many times from an identifiable common ancester.
Biological phylogenies assume a single common ancestor.
Malware often, maybe almost always, has more than
a single ancestor.

Souce code malware seems to evolve by feature addition or subtraction.
Malware modifiers add small chunks of code, code that might phone home
with URL, user ID and password, or just evaluate some code when
executed with a special CGI-BIN parameter.
Sometimes entire functions or subsystems are transplanted from another
program.

##Neighbor Joining

Tradtional biological phylogenies are sometimes calculated via some "distance" metric,
and tree construction algorithms like [Neighbor Joining](https://en.wikipedia.org/wiki/Neighbor_joining).

###Normalized Compression Distance

NCD algorithm from [Common Pitfalls Using The Normalized Compression Distance](http://www.ims.cuhk.edu.hk/~cis/2005.4/01.pdf)
it seems to give closer-to-zero "distance" of a piece of code to itself.

All files in `exemplars/` are PHP source code, normalized by [pretty printing](https://github.com/nikic/PHP-Parser),
and removing ASCII carriage return characters. I did an NCD calculation on all PHP malware in `exemplars`,
and using the neighbor joining algorithm, I produced the following phylogeny. To get a rooted tree
from neighbor joining, you have to pick an "outgroup". I chose `lfiscanner.php`.

![example move](https://raw.githubusercontent.com/bediger4000/malware-phylogeny/master/nj_phylogeny.png)

The horizontal lengths of branches are proportional to the normalized compression distance the
source files are apart.

NCD and neighbor joining get some parts of the phylogeny correct. Although I chose `lfiscanner`
as the out group, it found the `fx29` web shell as the next most distantly-related piece
of code. It gets the basic split between WSO 2.4 and WSO 2.5 clades, but mixes version 2.8 and 3.1
in the 2.4-based clade - both version 2.8 and 3.1 are clearly minor hacks of version 2.5.1

The assumptions inherent in neighbor joining make version 2.4 into an out group of a clade,
where it should be seen as the common ancestor of most of the verions in the sister clade.
Version 2.5 is the only code I have confidence of possessing the original. It should be
seen as the ancestor of a linear progression of 2.5 to 2.5.1 to 2.8 to 3.1.

All told, this phylogeny is roughly correct, but has too many flaws to be more than a general
guide.

##Algorithm

###Determine Features

###Description

1. order species by decreasing size of feature list in an array
2. Remove species with largest feature list from  array
3. Compare current feature list to other species in order from next largest feature list to smallest
4. When the other species has a feature list that's a strict subset of current feature list,
   assign current species as child of other species
5. Mark all traits of the current species common to the new parent.
6. If more than one trait is unmarked, repeat from (3)
7. If no more than one trait is unmarked, go to one.
8. If you have compared traits of the current species to all species
   and still have more than one unmarked traits, add the current species
   to the set of root species.

###Performance

Always terminates. Every species gets popped off ordered list of species.

####Worst case 
One root, many children, no grandchildren. All children have a lot of common traits,
one trait differentiating.  Worst case O(n^2) for comparison of traits.

###Effect of ill-chosen features

Two species without at least one trait to differentiate them.
Picking a trait that's not in the real ancester can lead to inversions
of descent.

##Example: Web Shell by oRb

###Description

"Web Shell by oRb" (also called "WSO", "FilesMan" and "AntiChat shell") is by far the most
popular web shell downloaded to hacked CMS web sites today. It's often reformmated, obfuscated
or otherwise slightly customized before hiding it in a WordPress installation. It also comes
in many distinct versions. "oRb" 

Why does WSO appear in so many versions? "oRb" wrote the code in a mostly modular fashion.
"oRb" actually designed the program. This makes it easier to add backdoors or phone-homes,
change password, modify page headers and footers, or add new functions.
This is in contrast to other web shells like `fx29`, `c99` or `r57`. All of these web shells
have an unholy mess inside, with little or no modularity, and no easy way to add functionality.
"oRb" also shepherded WSO through a corporate-style linear improvement process from versions 2.0
through 2.5 

Phylogeny image here

##Counter example: Perl IRC bot

Difficulty in picking out traits - some obviously later instances are selectively
trimmed versions of early instances. Huge variety of extra features added on.
Originally in Portugese, later transliterated into English.
